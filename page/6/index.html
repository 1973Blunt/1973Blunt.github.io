<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="email：summer15y@163.com">
<meta property="og:type" content="website">
<meta property="og:title" content="HotSummer">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="HotSummer">
<meta property="og:description" content="email：summer15y@163.com">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HotSummer">
<meta name="twitter:description" content="email：summer15y@163.com">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>





  <title> HotSummer </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HotSummer</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/26/ML-MLT-4-kernelLogisticRegression/" itemprop="url">
                  机器学习技法第五课——Kernel Logistic Regression
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-26T23:32:41+08:00" content="2016-06-26">
              2016-06-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第五课——Kernel Logistic Regression——的课程笔记。</p>
<p>这节课主要讨论了 SVM 与 Logistic 回归的相似性，其目标是解决“SVM 从 0/1 分类到概率分类的转换”以及“Logistic 从低维空间到高维空间的转换”，提出了二个方法，一是，将 SVM 训练结果代入 Logistic 中训练，二是，使用 Logistic Regression 的 kernel 模型进行训练。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/205_handout.pdf" target="_blank" rel="noopener">课件</a></li>
<li><a href="https://en.wikipedia.org/wiki/Platt_scaling" target="_blank" rel="noopener">Platt scaling</a></li>
<li><a href="/2016/06/05/ML-MLT-2-kernelSVM/" title="Kernel SVM">Kernel SVM</a>
</li>
</ul>
<h3 id="SVM-与-L2-正则化"><a href="#SVM-与-L2-正则化" class="headerlink" title="SVM 与 L2 正则化"></a>SVM 与 L2 正则化</h3><p>推导 <a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a> 的原始公式：<br>$$  \min<em>{b,\mathbf{w},\xi} \frac{1}{2}\mathbf{w^Tw} + C \sum</em>{n=1}^{N}\xi_n \\<br>s.t.\ y_n(\mathbf{w^Tz_n} + b) \ge 1 - \xi_n \\<br>s.t.\ \xi_n \ge 0<br>$$<br>$\xi$ 是松弛变量，也可视作 err，衡量越过 Margin 或分类超平面的程度，大致可以写成 $err = \xi_n = \max{(1-y_n(w^T z<em>n + b),\; 0)}$, 原式大概可以写成：<br>$$  \min</em>{b,\mathbf{w}} \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}{\max{(1-y_n(w^T z_n + b),\; 0)}}<br>$$<br>$$即\;\min{\frac{1}{2}\mathbf{w^Tw} + C\sum{err}}$$<br>这个公式与<a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习基石</a>部分的带 L2 正则化的 PLA 算法比较相似。SVM 大致可以视作一个带 L2 正则化的分类器。（这个 error 常被称作 hinge loss）</p>
<h3 id="SVM-与-Logistic-相似"><a href="#SVM-与-Logistic-相似" class="headerlink" title="SVM 与 Logistic 相似"></a>SVM 与 Logistic 相似</h3><p>令 $s=w^T z + b$ （超平面分类得分），引入<a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习基石</a>中的 0/1 错误、 Logistic 回归的错误与 SVM 错误比较：</p>
<table>
<thead>
<tr>
<th style="text-align:center">err type</th>
<th style="text-align:center">function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0/1</td>
<td style="text-align:center">[$ys \le 0$]</td>
</tr>
<tr>
<td style="text-align:center">logistic</td>
<td style="text-align:center">$\ln(1+\exp(-ys))$</td>
</tr>
<tr>
<td style="text-align:center">SVM</td>
<td style="text-align:center">$\max(1-ys,\; 0)$</td>
</tr>
</tbody>
</table>
<p>课程中作图更直观，在此就大致解释下 ：P。 $y, s$ 同号时，分类正确，0/1 分类中 “[]” 表示 bool 判断，如果 $ys \le 0$ 取1，反之取0，即分类正确 err 为 0，错误取 1 以记录错误。与之不同的是，Logistic 与 SVM 在分类错误时，不止记录了错误，而且在 $ys$ 越小时，err 取值越大。在分类正确时，后两者要么直接取 0，要么取一个 $0 \sim 1$ 的数。Logistic 与 SVM 都放大了分类错误数据的影响，而忽略分类正确数据的影响。</p>
<h3 id="Platt’s-scaling"><a href="#Platt’s-scaling" class="headerlink" title="Platt’s scaling"></a>Platt’s scaling</h3><p><a href="https://en.wikipedia.org/wiki/Platt_scaling" target="_blank" rel="noopener">Platt scaling</a> 又称 Platt calibration，将分类模型对数据的预测评分作为输入，训练 Logistic 模型，将它转化成概率模型。运用这个方法将 SVM 与 Logistic 结合，使得 SVM 拥有概率特征，而 Logistic 可以用 SVM kernel 处理多维空间转换。大致过程为</p>
<ul>
<li>run SVM get $\Phi_{svm}(z_n) = w^T z_n + b$</li>
<li>run Logistic problem get A, B:<br>$$  \min<em>{A, B} {\frac{1}{N} \sum</em>{n=1}^{N}{ \ln{(1 + \exp(-y<em>n (A \Phi</em>{svm}(z_n) + B)))} }}<br>$$<br>这里 A 是对 SVM 模型的一个放缩，对结果影响不大，而 B 有对原 SVM 有一定影响，应该尽量接近 0。在课程中，将这个模型称为 probabilistic SVM。</li>
</ul>
<h3 id="Kernel-Logistic-Regression"><a href="#Kernel-Logistic-Regression" class="headerlink" title="Kernel Logistic Regression"></a>Kernel Logistic Regression</h3><p>这一部分试图推导出 Logistic 的 kernel，以解决 Logistic 向高维空间映射的问题。提前声明一下，由于此模型不具有 SVM 的稀疏性，林老师在下节课会说明此方法相对 Platt’s scaling 较少使用。</p>
<p>首先，对于以下形式的“带 L2 正则化的线性模型”<br>$$  \min<em>{\mathbf{w}} \frac{\lambda}{N}\mathbf{w^Tw} + \frac{1}{N} \sum</em>{n=1}^{N}{err(y_n, w^T z<em>n)}<br>$$<br>老师用奇妙的方法证明了其中的 $\mathbf{w}$ 可以被 $\mathbf{z}$ 线性表示<br>$$\mathbf{w} = \sum</em>{n=1}^N \beta_n z_n$$<br>，而且该模型能被转换成 kernel 形式。（至于如何证明的，因为十分奇妙在此略过 ：P）</p>
<p>当然，带 L2 正则化的 Logistic 回归模型符合以上条件。<br>$$  \min<em>{w} { \frac{\lambda}{N}\mathbf{w^Tw}  +\frac{1}{N} \sum</em>{n=1}^{N}{ \ln{(1 + \exp(-y_n w^T z_n))} }}<br>$$</p>
<p>在 <a href="/2016/06/05/ML-MLT-2-kernelSVM/" title="Kernel SVM">Kernel SVM</a> 中，用 kernel 函数 $K(\mathbf{x, x’})$ 替换 $\mathbf{z^Tz’}$，所以，接下来要把高维空间的 $\mathbf{w, z}$ 用 kernel 替换。<br>$$ \mathbf{w^Tw} = \sum<em>{n=1}^{N}\sum</em>{n=1}^{M} \beta_n \beta_m K(\mathbf{x_n, x_m})\quad （向量内积分配律）\\<br> \mathbf{w^Tz<em>n} = \sum</em>{m=1}^N {\beta_m K(\mathbf{x_m, x_n})}<br>$$</p>
<p>最后问题变成求解 $\beta$<br>$$  \min<em>{w} { \frac{\lambda}{N} \sum</em>{n=1}^{N}\sum_{n=1}^{M} \beta_n \beta_m K(\mathbf{x_n, x<em>m})<br> +\frac{1}{N} \sum</em>{n=1}^{N}{ \ln{(1 + \exp(-y<em>n \sum</em>{m=1}^N {\beta_m K(\mathbf{x_m, x_n})}))} }}<br>$$<br>需要说明，$\beta$ 往往非 0，而对比 SVM 中的 $\alpha$，则大多是 0（非支持向量），后者具有稀疏性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/09/ML-MLT-3-softSVM/" itemprop="url">
                  机器学习技法第四课——Soft-Margin SVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-09T18:31:14+08:00" content="2016-06-09">
              2016-06-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是本人学习林轩田老师的机器学习技法第四课——Soft-Margin Support Vector Machine——的课堂笔记。</p>
<p>前几节课的 SVM 不能容忍错误——包括不可分错误及可分分却在 margin 内的错误，这节课要解决这个问题，推导出 Soft Margin SVM。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/204_handout.pdf" target="_blank" rel="noopener">课件</a></li>
<li><a href="http://taop.marchtea.com/07.02.svm.html" target="_blank" rel="noopener">支持向量机</a></li>
<li><a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a>
</li>
</ul>
<h3 id="松弛变量"><a href="#松弛变量" class="headerlink" title="松弛变量"></a>松弛变量</h3><p>引入松弛变量 $\xi$，放宽条件，同时避免过度放宽，在最小化公式中也加入 $\xi$：<br>$$  \min<em>{b,\mathbf{w},\xi} \frac{1}{2}\mathbf{w^Tw} + C \sum</em>{n=1}^{N}\xi_n \\<br>s.t.\ y_n(\mathbf{w^Tz_n} + b) \ge 1 - \xi_n \\<br>s.t.\ \xi_n \ge 0<br>$$<br>此处 $C$ 是一个常量，作为平衡“large margin”与”margin violation”的参数。<br>$\xi$ 在限制条件中确实减小了下限，放宽了条件，但至于这背后为何能使 SVM 容忍错误，这可能要从头开始推导了。很明显，这已经可以用二次规划求解。</p>
<h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>转换成对偶问题，用前面课程 <a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a> 中同样的方法。</p>
<h4 id="拉格朗日乘数"><a href="#拉格朗日乘数" class="headerlink" title="拉格朗日乘数"></a>拉格朗日乘数</h4><p>$$  L(b,\mathbf{w},\alpha,\beta) = \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}\xi<em>n + \sum</em>{n=1}^N \alpha_n(1-\xi_n-y_n(\mathbf{w^T z<em>n} + b)) + \sum</em>{n=1}^N \beta_n (-\xi<em>n)<br>$$<br>求解：<br>$$   \max</em>{\alpha_n \ge 0,\ \beta<em>n \ge 0} (min</em>{b,\mathbf{w},\xi} L(b,\mathbf{w},\alpha,\beta))<br>$$</p>
<h4 id="求导化简成关于-alpha-的函数"><a href="#求导化简成关于-alpha-的函数" class="headerlink" title="求导化简成关于 $\alpha$ 的函数"></a>求导化简成关于 $\alpha$ 的函数</h4><p>$$    \frac{\partial L}{\partial \xi_n} = C - \alpha_n - \beta_n\\<br>let\ \ \beta_n= C -\alpha_n<br>$$<br>因为条件中有 $\alpha_n \ge 0$，故 $C \ge \alpha<em>n \ge 0$。如此原式变换为：<br>$$    \max</em>{$0 \le \alpha_n \le C,\ \beta_n=C-\alpha<em>n} (\min</em>{b,\mathbf{w},\xi} \frac{1}{2} \mathbf{w^T w} + \sum_{n=1}^{N}\alpha_n(1 - y_n(\mathbf{w^T \mathbf{z_n}} + b)))<br>$$<br>这一步增加了限制条件，但消去了 $\beta, \xi, C$。接下来与 <a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a> 的过程相同，令 $\frac{\partial L}{\partial b} = 0, \frac{\partial L}{\partial w<em>i} = 0$ 化简得：<br>$$<br>\min</em>{\alpha<em>n} (\frac{1}{2}\sum</em>{m=1}^{N} \sum_{n=1}^{N} y_m  y_n \mathbf{z_m^T} \mathbf{z_n} \alpha_m \alpha<em>n - \sum</em>{n=1}^{N}\alpha<em>n) \\<br>s.t.\ \ \sum</em>{n=1}^N y_n \alpha_n = 0,\ \ all\ 0 \le \alpha_n \le C<br>$$<br>看上去与之前的差别只有对 $\alpha$ 加上上限 C。</p>
<h4 id="求解-b"><a href="#求解-b" class="headerlink" title="求解 $b$"></a>求解 $b$</h4><p>部分 KKT 条件：<br>$$  \alpha_n(1-\xi_n-y_n(\mathbf{w^T z_n} + b)) = 0 \\<br>(C - \alpha_n) \xi_n = 0  $$<br>因为除 $\xi,\ b$ 其他都是已知量，所以只要求解方程组就能得到解。而多数情况下，当 $0 \lt \alpha_n \lt C$ 时，被称为 free Support Vector，可推导出<br>$$  b = y_s - \mathbf{w^T z_s}<br>$$<br>之后的求解过程与前面课程没什么不同。</p>
<h3 id="alpha-n-与向量角色"><a href="#alpha-n-与向量角色" class="headerlink" title="$\alpha_n$ 与向量角色"></a>$\alpha_n$ 与向量角色</h3><p>根据 KKT 条件，当 $\alpha_n = 0$ 时，松弛变量 $\xi_n=0$，没有错误，被称为非支持向量，<strong><em>non SV</em></strong>，处于 margin 外界；</p>
<p>当 $0 \lt \alpha \lt C$ 时，$\xi_n=0$，没有错误，而且可以求解 $b$，被称为 <strong><em>free SV</em></strong>，位于 margin 上；</p>
<p>当 $\alpha = C$ 时， $\xi_n \ne 0$，有错误，同样可以帮助求解，被称为 <strong><em>bounded SV</em></strong>，位于 margin 内部或越过了超平面。</p>
<h3 id="LOOC-帮助模型选择"><a href="#LOOC-帮助模型选择" class="headerlink" title="LOOC 帮助模型选择"></a>LOOC 帮助模型选择</h3><p>模型选择时，可以用 Cross Validation 做参考，其中特别的有 Leave-One-Out CV，即只留一个数据点做验证。</p>
<p>将 Leave-One-Out CV 与全数据集（不留验证数据）的训练做比较。如果验证数据是一个 non-SV，那么，2 者的错误是相同的，而如果验证数据是一个 SV，那么有可能分类错误。所以有<br>$$  E_{loocv} \le \frac{num(SV)}{N} $$<br>这里存在疑问的是，如果验证数据是一个很关键的 SV，可能极大地影响超平面的训练结果，这个 bound 是否成立。</p>
<p>这个上限可以用做安全检查，在训练模型之后便能得到 $E_{loocv}$ 的上限，可以排除一些结果太差的模型，节省时间，但它的作用有限，不能断定一个模型的好坏。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/07/Algo-asymptoticAnalysis/" itemprop="url">
                  算法时间复杂度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-07T21:07:37+08:00" content="2016-06-07">
              2016-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index">
                    <span itemprop="name">Algo</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Coursera 上 <a href="https://class.coursera.org/algo-009/lecture" target="_blank" rel="noopener">Algorithms: Design and Analysis, Part 1 by Tim Roughgarden</a> 的学习笔记。第二课，有关时间复杂度。</p>
<h4 id="The-Gist"><a href="#The-Gist" class="headerlink" title="The Gist"></a>The Gist</h4><p>时间复杂度计算概略地讲，就是“suppress constant factors and lower-order terms”</p>
<h4 id="Big-Oh-Notation"><a href="#Big-Oh-Notation" class="headerlink" title="Big-Oh Notation"></a>Big-Oh Notation</h4><p>Formal Definition: $T(n) = O(f(n))$ \<br>if and only if exist constants $c, n_0$ such that $T(n) \le cf(n)$ \<br>for all $n \gt n_0$</p>
<p>即 $n \rightarrow +\infty$ 时，$cf(n)$ 为 $T(n)$ 上限</p>
<h4 id="Omega-Notation"><a href="#Omega-Notation" class="headerlink" title="Omega Notation"></a>Omega Notation</h4><p>Formal Definition: $T(n) = \Omega(f(n))$ \<br>if and only if exist constants $c, n_0$ such that $T(n) \ge cf(n)$ \<br>for all $n \gt n_0$</p>
<p>即 $n \rightarrow +\infty$ 时，$cf(n)$ 为 $T(n)$ 下限</p>
<h4 id="Theta-Notation"><a href="#Theta-Notation" class="headerlink" title="Theta Notation"></a>Theta Notation</h4><p>Formal Definition: $T(n) = \Theta(f(n))$ \<br>if and only if $T(n)=O(f(n))$ and $\Omega(n)=O(f(n))$</p>
<p>即 $n \rightarrow +\infty$ 时，$cf(n)$ 既能作 $T(n)$ 下限也能作上限，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/05/ML-MLT-2-kernelSVM/" itemprop="url">
                  机器学习技法第三课——Kernel SVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-05T21:45:49+08:00" content="2016-06-05">
              2016-06-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第三课——Kernel Support Vector Machine——的课堂笔记。</p>
<p>给定上节课的公式：<br>$$<br>\min_{\alpha<em>n} (\frac{1}{2}\sum</em>{m=1}^{N} \sum_{n=1}^{N} y_m y_n \mathbf{z_m^T}  \mathbf{z_n} \alpha_m \alpha<em>n - \sum</em>{n=1}^{N}\alpha_n) \\<br>s.t.\ all\ \alpha<em>n \ge 0,\ \sum</em>{n=1}^N \alpha_n y_n = 0<br>$$<br>这里 $\mathbf{z}$ 是由 $\mathbf{x}$ 变换得到。在 $\mathbf{x}$ 向量所处的空间里，如果所有超平面都不能对数据进行分类，可以将 $\mathbf{x}$ 映射到高维空间，也就是 $\mathbf{x}$ 变换成 $\mathbf{z}$。这次课的目标包括：了解这种变换带来的求解问题，引入核函数、多项式核函数、高斯核函数，及了解如何选择核 SVM 或线性 SVM。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/203_handout.pdf" target="_blank" rel="noopener">课件</a></li>
</ul>
<h3 id="求解复杂度"><a href="#求解复杂度" class="headerlink" title="求解复杂度"></a>求解复杂度</h3><p>考虑将 $\mathbf{x}$ 从一次变换到二次：<br>$$\mathbf{x} = (x_1, x_2, …, x_d) \ \ \rightarrow \\<br>\mathbf{z} = (1, x_1, x_2, …, x_d, x_1 x_1, x_1 x_2, …, x_1 x_d, x_2 x_1, x_2 x_2, …, x_2 x_d, …, x_d x_d)$$</p>
<p>向量长度增加了 $d^2 + 1$，由于在求解公式中需要计算任意2个 $\mathbf{x}$ 的内积（$\mathbf{z_m^T z_n}$），计算复杂度从 $o(d^2)$ 增加到 $o(d^4)$，陡增了不少困难。而这仅是变换到二次的情况。</p>
<h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>就 <strong><em>求解复杂度</em></strong> 一节所举一次变二次，有以下推导：<br>$$\mathbf{z^T z’} = 1 + \sum_{i=1}^d x_i x’<em>i + \sum</em>{i=1}^d \sum_{j=1}^d x_i x_j x’_i x’<em>j \\<br>=1 + \sum</em>{i=1}^d x_i x’<em>i + (\sum</em>{i=1}^d x_i x’<em>i) (\sum</em>{j=1}^d x_j x’_j) \\<br>=1 + \mathbf{x^T x’} + (\mathbf{x^T x’})(\mathbf{x^T x’})$$<br>可见任意2个 $\mathbf{w}$ 的内积（$\mathbf{z^T z’}$）可以用 $\mathbf{x}$ 的内积表示。这可以推广到更高次变换。</p>
<p>这种处理有何好处？复杂度大幅降低，从原来的 $o(d^4)$ 回降到 $o(d^2)$。</p>
<h4 id="核函数-1"><a href="#核函数-1" class="headerlink" title="核函数"></a>核函数</h4><p>简单来说，核函数（核）应该是：<br>$$\mathbf{z^T z’} = K(\mathbf{x}, \mathbf{x’})$$<br>在一次变二次例子中 $K(\mathbf{x}, \mathbf{x’}) =1 + \mathbf{x^T x’} + (\mathbf{x^T x’})(\mathbf{x^T x’})$。</p>
<p>原求解公式变换为：<br>$$<br>\min_{\alpha<em>n} (\frac{1}{2}\sum</em>{m=1}^{N} \sum_{n=1}^{N} y_m y_n K(\mathbf{x}_m, \mathbf{x}_n) \alpha_m \alpha<em>n - \sum</em>{n=1}^{N}\alpha_n) \\<br>s.t.\ all\ \alpha<em>n \ge 0,\ \sum</em>{n=1}^N \alpha_n y_n = 0<br>$$<br>设 $(\mathbf{x}_s, y_s)$ 为支持向量（$\alpha_s = 0$）解出 $b$:<br>$$<br>b = y_s - \mathbf{w^T \mathbf{z_s}} \\<br>= y<em>s - (\sum</em>{n=1}^{N} \alpha_n y_n \mathbf{z_n})^\mathbf{T} \mathbf{z}_s \\<br>= y<em>s - \sum</em>{n=1}^{N} \alpha_n y_n K(\mathbf{x}_n, \mathbf{x}<em>s)<br>$$<br>求解 $\mathbf{w}$ 似乎有点复杂，但不影响最终分类。分类公式变换为<br>$$g</em>{svm}(\mathbf{x}) = sign(\mathbf{w^T z} + b)<br>=sign(\sum_{n=1}^{N} \alpha_n y_n K(\mathbf{x}_n, \mathbf{x}) + b)$$</p>
<h4 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h4><p>$$K(\mathbf{x}, \mathbf{x’}) = (\zeta + \gamma \mathbf{x^T x’})^q,\ with\ \zeta \ge 0,\ \gamma \gt 0$$<br>例如，当 $q = 2$ 时，<br>$$\mathbf{z^T z’} = K(\mathbf{x}, \mathbf{x’}) =1 + 2\zeta\gamma\mathbf{x^T x’} + \gamma^2(\mathbf{x^T x’})^2 \\<br>\Rightarrow \mathbf{z} = (1, \sqrt{2\zeta\gamma}x_1,  \sqrt{2\zeta\gamma}x_2, …,  \sqrt{2\zeta\gamma}x_n, \gamma x_1 x_1, \gamma x_1 x_2, …, \gamma x_n x_n)$$<br>感觉这个核不能满足所有从 $\mathbf{x}$ 到 $\mathbf{z}$ 的多项式变换，比如 $\mathbf{z}$ 中至少所有一次项系数都相等（在上例中为 $\sqrt{2\zeta\gamma}$）。</p>
<h4 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h4><p>$$K(\mathbf{x}, \mathbf{x’}) = exp(-\gamma |\mathbf{x - x’}|^2),\ with\ \gamma \gt 0$$<br>高斯（Gaussian）核函数可以将 $\mathbf{x}$ 扩展到无限维。</p>
<p>课上只给了 $\gamma = 1,\ \mathbf{x} = (x)$（$\mathbf{x}$ 只有一个维度）时的推导：<br>$$K(\mathbf{x}, \mathbf{x’}) = exp(-(\mathbf{x - x’})^2) \\<br>=exp(-x^2)exp(-x’^2)exp(2xx’)\\<br>=exp(-(x)^2)exp(-(x’)^2) \sum<em>{i=0}^\infty \frac{(2xx’)^i}{i!},\ \ taylor\ expansion \\<br>=\sum</em>{i=0}^\infty(exp(-x^2)exp(-x’^2) \sqrt{\frac{2^i}{i!}} \sqrt{\frac{2^i}{i!}} x^i x’^i) \\<br>=\mathbf{z^T z’} \\<br>with\ \mathbf{z}=exp(-x^2)(1, \sqrt{\frac{2}{1!}} x, \sqrt{\frac{2^2}{2!}}x^2, …)<br>$$</p>
<p>如果 $\gamma$ 取值过大（方差过大），高斯核会过拟合。</p>
<h3 id="核函数并非万能"><a href="#核函数并非万能" class="headerlink" title="核函数并非万能"></a>核函数并非万能</h3><p>线性 SVM 指原始的，$\mathbf{x}$ 未经变换的 SVM，求解相对多项式核 SVM 简单（系数矩阵为对角矩阵），而且，参数选择较少。而高斯核的模型难以解释，且容易过拟合。</p>
<p>对于高次的多项式 kernel，可以考虑用原始的方法，将 $\mathbf{x}$ 转化成 $\mathbf{z}$ 之后代入线性 SVM 求解，如果维度不高，求解速度会更快。</p>
<h3 id="其他核函数"><a href="#其他核函数" class="headerlink" title="其他核函数"></a>其他核函数</h3><p>课上指出，能成为核函数的充要条件是，核函数导出的矩阵 $\mathbf{K}$，$k_{i,j}=K(\mathbf{x_i, x_j})$，是对称且半正定的。这2个条件被称为 Mercer’s condition。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/Python-cheatSheet/" itemprop="url">
                  Python 杂记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-03T10:58:50+08:00" content="2016-06-03">
              2016-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/sasoritattoo/article/details/12451359" target="_blank" rel="noopener">python代码 `if not x:` 和`if x is not None:`和`if not x is None:`使用</a></li>
<li><a href="http://www.2cto.com/kf/201405/300359.html" target="_blank" rel="noopener">python变量和作用域</a></li>
<li><a href="http://www.cnblogs.com/ifantastic/archive/2013/04/15/3021845.html" target="_blank" rel="noopener">Python 序列的切片操作与技巧</a></li>
</ul>
<h3 id="函数和常用语法"><a href="#函数和常用语法" class="headerlink" title="函数和常用语法"></a>函数和常用语法</h3><h4 id="raw-input-与-input"><a href="#raw-input-与-input" class="headerlink" title="raw_input 与 input"></a>raw_input 与 input</h4><p><code>raw_input</code> 只在 2 中存在，返回字符串，在 2 中，<code>input</code> 返回输入表达式的值；\<br>3 中 input 返回字符串。</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>查看变量类型</p>
<h4 id="交换两变量值"><a href="#交换两变量值" class="headerlink" title="交换两变量值"></a>交换两变量值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<h4 id="while-for-else-语句"><a href="#while-for-else-语句" class="headerlink" title="while/for else 语句"></a>while/for else 语句</h4><p>跟 if else 相同，在 while/for 条件为假时执行 else。所以，在未进入循环或循环正常完成后，else 部分会执行，而循环被 break 或出现异常，则不会执行 else。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">"Sat"</span>,<span class="string">"Sun"</span>,<span class="string">"Mon"</span>]:</span><br><span class="line">  <span class="keyword">if</span> value == <span class="string">"Sun"</span>:</span><br><span class="line">    print(<span class="string">"Bingo!"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">"No Sunday."</span>)</span><br></pre></td></tr></table></figure>
<h4 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h4><p>在函数中使用 yield 关键字让函数返回一个 <strong>生成器</strong>。 该生成器调用方式十分奇特，类似于断点调试，在调用其 <code>next()</code> 方法时运行到 yield 关键字处并返回参数，可多次调用直到函数结束（抛出 StopIteration 异常）。可以在函数中使用多个 yield，就像设置多个断点。隐含的一个特性是，每次只能取到下一个值，而不能回退取到上一个值。通常用 <code>for/while</code> 循环使用生成器，以代替循环调用 <code>next()</code>，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(stop)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"step in"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(stop):</span><br><span class="line">        <span class="keyword">yield</span> i  <span class="comment"># 当代码运行到此处返回 i</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"yield %g"</span> % i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">g = gen(<span class="number">3</span>)  <span class="comment"># 函数返回一个生成器</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"called gen"</span>  <span class="comment"># 在调用 g.next() 方法前，gen 内代码不会执行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<h4 id="sign-函数"><a href="#sign-函数" class="headerlink" title="sign 函数"></a>sign 函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = <span class="keyword">lambda</span> a: <span class="number">1</span> <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="print-不换行"><a href="#print-不换行" class="headerlink" title="print 不换行"></a>print 不换行</h4><p>python2 中 print 不换行，python3 中使用参数 <code>end=&#39;&#39;</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World"</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="dict-键列表"><a href="#dict-键列表" class="headerlink" title="dict 键列表"></a>dict 键列表</h4><p>使用 <code>list(dict)</code> 获取 <code>dict</code> 的键列表</p>
<h3 id="惯用处理"><a href="#惯用处理" class="headerlink" title="惯用处理"></a>惯用处理</h3><h4 id="pip-更换仓库源"><a href="#pip-更换仓库源" class="headerlink" title="pip 更换仓库源"></a>pip 更换仓库源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy -i http://pypi.mirrors.ustc.edu.cn/simple/ <span class="comment"># 临时用中科大源安装numpy</span></span><br></pre></td></tr></table></figure>
<h4 id="pip-下载安装包并离线安装"><a href="#pip-下载安装包并离线安装" class="headerlink" title="pip 下载安装包并离线安装"></a>pip 下载安装包并离线安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 只下载包</span><br><span class="line">pip download -d ./download_packs_dir -r ./requirements.txt</span><br><span class="line"># 只安装</span><br><span class="line">pip install --no-index --find-links=./download_packs_dir -r ./requirements.txt</span><br></pre></td></tr></table></figure>
<h4 id="从文件路径获取文件名与扩展名"><a href="#从文件路径获取文件名与扩展名" class="headerlink" title="从文件路径获取文件名与扩展名"></a>从文件路径获取文件名与扩展名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">filepath = <span class="string">'/tmp/log.txt'</span></span><br><span class="line">filename = os.path.basename(filepath) <span class="comment"># 文件名</span></span><br><span class="line">print(os.path.splitext(filename)) <span class="comment"># 分离扩展名</span></span><br></pre></td></tr></table></figure>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>datetime 与 字符串相互转换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">id_s = <span class="string">"337259199211056344"</span>[<span class="number">6</span>:<span class="number">14</span>] <span class="comment"># 身份证号</span></span><br><span class="line">d = datetime.strptime(id_s, <span class="string">'%Y%m%d'</span>)</span><br><span class="line">print((datetime.now() - d).days)  <span class="comment"># 距今多少天，datetime相减得delta对象</span></span><br><span class="line">print(d.strftime(<span class="string">'%Y-%m-%d'</span>)) <span class="comment"># datetime 格式化输出字符串</span></span><br></pre></td></tr></table></figure></p>
<h4 id="判断对象为数字"><a href="#判断对象为数字" class="headerlink" title="判断对象为数字"></a>判断对象为数字</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">print(isinstance(x, numbers.Number))</span><br></pre></td></tr></table></figure>
<h4 id="读-excel-表"><a href="#读-excel-表" class="headerlink" title="读 excel 表"></a>读 excel 表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(excel_name, sheet_name)</span>:</span></span><br><span class="line">    bk = xlrd.open_workbook(excel_name)</span><br><span class="line">    sh = bk.sheet_by_name(sheet_name)</span><br><span class="line"></span><br><span class="line">    nrows = sh.nrows <span class="comment">#获取行数</span></span><br><span class="line">    ncols = sh.ncols <span class="comment">#获取列数</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"excel %s, sheet %s, nrows %d, ncols %d"</span> % (excel_name, sheet_name, nrows,ncols))</span><br><span class="line"></span><br><span class="line">    row_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, nrows):    <span class="comment">#获取各行数据</span></span><br><span class="line">        row_data = sh.row_values(i)</span><br><span class="line">        row_list.append(row_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> row_list</span><br></pre></td></tr></table></figure>
<h4 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h4><h5 id="random"><a href="#random" class="headerlink" title="random"></a>random</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.random() <span class="comment"># 0 到 1 小数</span></span><br><span class="line">random.randint(m,n) <span class="comment"># m 到 n 整数</span></span><br><span class="line">random.sample(list, n) <span class="comment"># 从 list 不放回抽样 n 个，返回列表</span></span><br></pre></td></tr></table></figure>
<h5 id="正态随机"><a href="#正态随机" class="headerlink" title="正态随机"></a>正态随机</h5><p>生成正态随机数列可用<code>numpy.random.normal(mu, sigma, sample_num)</code></p>
<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>匹配例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"截止日期：2016-7-11 2:44:29。余额：137533。逾期金额：28747。"</span></span><br><span class="line">print(re.findall(<span class="string">r"余额：(.+?)。"</span>, str))</span><br></pre></td></tr></table></figure></p>
<h3 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h3><h4 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(stat=0,stop,step=1)</span></span><br><span class="line">range(<span class="number">10</span>) <span class="comment"># 返回 0 到 9 列表</span></span><br><span class="line">range(<span class="number">1</span>,<span class="number">10</span>) <span class="comment"># 返回 1 到 9 列表</span></span><br><span class="line">range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># 返回以 2 为步长 1 到 9 列表</span></span><br><span class="line">range(<span class="number">0</span>,<span class="number">-10</span>,<span class="number">-1</span>) <span class="comment"># 返回 0 到 -9 列表</span></span><br></pre></td></tr></table></figure>
<h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="comment"># 创建一个新 list</span></span><br></pre></td></tr></table></figure>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>list 切片作为右值，会复制数据并返回引用。而对切片的修改会直接作用于原 list 上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list[start:stop:step], 用法类似 range，如果意义明确，可省略参数</span></span><br><span class="line"><span class="comment"># 索引可为负，可以超出范围</span></span><br><span class="line">la = lb <span class="comment"># 只能复制引用</span></span><br><span class="line">la = lb[:] <span class="comment"># 复制数据，返回引用给 la</span></span><br><span class="line">lb[::<span class="number">-1</span>] <span class="comment"># lb 逆序列表 copy</span></span><br><span class="line">lb[<span class="number">-2</span>:<span class="number">-1</span>] = [<span class="number">2</span>, <span class="number">4</span>] <span class="comment"># 将 lb 最后两个数赋为 2, 4</span></span><br><span class="line"><span class="keyword">del</span> lb[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 删除 lb 第 0、1 号元素</span></span><br></pre></td></tr></table></figure></p>
<h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.append(x) <span class="comment"># 追加到末尾</span></span><br><span class="line">list.insert(i, x) <span class="comment"># 插入到 i 处</span></span><br><span class="line">la = lb + lc <span class="comment"># 创建一个新 list，顺序加入 lb、lc 中元素</span></span><br><span class="line">la.extend(lb) <span class="comment"># 在 la 中依次添加 lb 中元素</span></span><br></pre></td></tr></table></figure>
<h4 id="判断元素存在"><a href="#判断元素存在" class="headerlink" title="判断元素存在"></a>判断元素存在</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">in</span> list <span class="comment"># 返回 bool 类型，是否存在 x</span></span><br><span class="line">list.count(x) <span class="comment"># 返回 x 出现次数</span></span><br></pre></td></tr></table></figure>
<h4 id="按索引查元素"><a href="#按索引查元素" class="headerlink" title="按索引查元素"></a>按索引查元素</h4><p>索引可为负，范围： [-len, len-1]</p>
<h4 id="按元素查索引"><a href="#按元素查索引" class="headerlink" title="按元素查索引"></a>按元素查索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.index(x) <span class="comment"># 第一次出现 x 位置，如果 x 不存在会报错</span></span><br></pre></td></tr></table></figure>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> list[index] <span class="comment"># 删除 index 处元素</span></span><br><span class="line">list.remove(x) <span class="comment"># 删除 x 元素，如果不存在会报错</span></span><br><span class="line">list.pop(index=<span class="number">-1</span>) <span class="comment"># 返回并删除 index 处元素</span></span><br><span class="line"><span class="comment"># 直接用切片复制保留元素到新列表中，也是一种方法</span></span><br></pre></td></tr></table></figure>
<h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.reverse()</span><br></pre></td></tr></table></figure>
<h4 id="zip-合并"><a href="#zip-合并" class="headerlink" title="zip 合并"></a>zip 合并</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip(la,lb,lc) <span class="comment"># “同索引元素”组成元组，构成列表，长度为输入最短列表的长度</span></span><br><span class="line">[a + b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(la,lb)]</span><br></pre></td></tr></table></figure>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>一个模块是一个源文件，文件名即模块名。模块由 <code>import</code> 语句加载后，便可以访问其中定义的对象。</p>
<h4 id="import-与-from-import"><a href="#import-与-from-import" class="headerlink" title="import 与 from import"></a>import 与 from import</h4><p>当 python 解释器 <code>import</code> 一个模块时，会执行其中的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module <span class="comment"># 加载 module，使用其中对象时应该用 module.obj</span></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> obj <span class="comment"># 加载 module，只能使用 obj 对象，不用加 module 前缀</span></span><br></pre></td></tr></table></figure></p>
<h4 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__ 属性"></a><code>__name__</code> 属性</h4><p>当 python 解释器加载一个模块时，会设置每个模块的属性 <code>__name__</code>。 只有当前运行模块的该属性被设置为 <code>__main__</code>，所以可用以下语句判断当前模块是否是程序入口<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h4 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sys.path 列表存储了模块搜索路径</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path <span class="comment"># 可修改该列表以修改模块搜索路径</span></span><br></pre></td></tr></table></figure>
<p>搜索路径初始包括：</p>
<ul>
<li>运行脚本目录</li>
<li>环境变量 PYTHONPATH 中存储的值</li>
<li>Python 模块的安装目录</li>
</ul>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir() <span class="comment"># 返回当前模块定义的对象名列表</span></span><br><span class="line">dir(module) <span class="comment"># 返回 module 定义的对象名列表</span></span><br></pre></td></tr></table></figure>
<h4 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h4><p>三种方式：</p>
<p>进入下载安装包目录，运行 setup.py 程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码安装</span></span><br><span class="line">cd download_dir</span><br><span class="line">python setup.py install <span class="comment"># 运行 setup.py 安装程序</span></span><br><span class="line"><span class="comment"># 用 pip 安装，自动安装依赖包</span></span><br><span class="line">pip install PackageName</span><br><span class="line"><span class="comment"># 用 easy_install 安装，不推荐使用</span></span><br><span class="line">easy_install PackageName</span><br></pre></td></tr></table></figure></p>
<h4 id="win下-Anaconda-安装依赖包"><a href="#win下-Anaconda-安装依赖包" class="headerlink" title="win下 Anaconda 安装依赖包"></a>win下 Anaconda 安装依赖包</h4><p>进入Anaconda安装目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Scripts</span><br><span class="line">pip install PackageName -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"># -i 后接国内镜像地址url，提升速度</span><br></pre></td></tr></table></figure></p>
<p>更换conda源（清华）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure></p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>是一个包含 __init__.py 的文件夹，导入模块时需要加上包前缀，类似 Java。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="三大作用域"><a href="#三大作用域" class="headerlink" title="三大作用域"></a>三大作用域</h4><p>只有模块（module），类（class）以及函数（<code>def</code>、<code>lambda</code>）才会引入新的作用域，其它的代码块（如if、try、for等，甚至列表推导式也是）不会引入新的作用域</p>
<h4 id="子级作用域与上级"><a href="#子级作用域与上级" class="headerlink" title="子级作用域与上级"></a>子级作用域与上级</h4><p>在子级作用域可访问上级作用域变量。让上级变量指向另一个对象不能使用语句 <code>same_name = obj</code>， 该句被视为在子级作用域定义一个同名变量，并隐藏了上级变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"read y: %d"</span> % y) <span class="comment"># 读取全局变量</span></span><br><span class="line">  x = <span class="number">1</span>   <span class="comment"># 创建一个局部变量 x</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">run()</span><br><span class="line">print(<span class="string">"global x: %d"</span> % x)</span><br></pre></td></tr></table></figure>
<h4 id="global-与-nonlocal-语句"><a href="#global-与-nonlocal-语句" class="headerlink" title="global 与 nonlocal 语句"></a>global 与 nonlocal 语句</h4><p>如果想在子级作用域中让上级作用域变量指向其他对象，可以用 <code>global</code> 与 <code>nonlocal</code> 语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># nonlocal x 这样声明会报错，python 不能找到非全局的上级变量 x</span></span><br><span class="line">    x, y = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = <span class="number">2</span></span><br><span class="line">        <span class="keyword">global</span> y</span><br><span class="line">        y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    print(<span class="string">"outer:"</span>, x, y)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"global:"</span>, x, y)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># outer: 2 1</span></span><br><span class="line"><span class="comment"># global: 0 2</span></span><br></pre></td></tr></table></figure>
<p><code>global</code> 最先出现，用于在局部引用全局变量，随后又加入 <code>nonlocal</code>，使子级作用域引用 <strong>非全局的</strong> 上级变量。</p>
<h4 id="类变量与实例变量"><a href="#类变量与实例变量" class="headerlink" title="类变量与实例变量"></a>类变量与实例变量</h4><p>类变量的定义与访问其中两种方式：</p>
<ul>
<li><code>class_name.class_var</code></li>
<li>类定义内方法定义外 <code>class_var</code></li>
</ul>
<p>实例变量定义与访问有两种方式：</p>
<ul>
<li><code>obj_name.obj_var</code></li>
<li>在有 <code>self</code> 参数的方法定义中 <code>self.obj_var</code></li>
</ul>
<p>用访问实例的方式可以访问类变量，就像 <strong>在子级作用域访问上级变量</strong>，只能访问而不能让其指向另一个对象，而且如果实例变量与类变量同名则访问实例变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span>:</span></span><br><span class="line">    v1 = <span class="number">0</span>  <span class="comment"># 定义类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.v1 = <span class="number">1</span>   <span class="comment"># 定义实例变量，隐藏同名类变量</span></span><br><span class="line"></span><br><span class="line">cls.v2 = <span class="number">0</span>  <span class="comment"># 定义类变量</span></span><br><span class="line">obj = cls()</span><br><span class="line"><span class="keyword">print</span> cls.v1, cls.v2  <span class="comment"># 访问类变量</span></span><br><span class="line"><span class="keyword">print</span> obj.v1, obj.v2  <span class="comment"># 分别访问实例变量 v1 与类变量 v2</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>类似 C 语言的格式化字符串，用 % 号连接模板字符串（Template）与匹配元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'%s is a string. %d is a int.'</span> % (<span class="string">"Hello World"</span>, <span class="number">0</span>) <span class="comment"># 该表达式返回一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可将元组替换成字典，模板对应加入 (key)</span></span><br><span class="line"><span class="string">"I'm %(name)s, and I love %(num)g."</span> % &#123;<span class="string">"num"</span>:math.pi, <span class="string">"name"</span>:<span class="string">"Mike"</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原生字符串（常量）"><a href="#原生字符串（常量）" class="headerlink" title="原生字符串（常量）"></a>原生字符串（常量）</h4><p>在字符串字面量前加 r ，会使之成为原生字符串字面量，不会对字符进行转义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r"\n"</span> == <span class="string">"\\n"</span> <span class="comment"># 返回 True</span></span><br></pre></td></tr></table></figure>
<h4 id="加操作"><a href="#加操作" class="headerlink" title="加操作"></a>加操作</h4><p><strong>字符串只允许与字符串进行加操作</strong></p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>函数形参（函数定义参数）复制了实参（传入函数的变量）的引用，类似 Java，对形参引用对象的修改实际上在修改实参引用对象，但让形参指向其他对象不会对实参有影响。</p>
<h4 id="缺省与变长"><a href="#缺省与变长" class="headerlink" title="缺省与变长"></a>缺省与变长</h4><p>函数参数的定义顺序与调用顺序应该遵循：关键字参数–&gt;缺省参数–&gt;变长参数–&gt;关键字参变长数</p>
<h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>最基本的一类参数，调用时可指明形参名（关键字）。与其他参数不同，必需赋值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> a, b</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 一般调用方法</span></span><br><span class="line">fun(b=<span class="number">1</span>, a=<span class="number">2</span>)  <span class="comment"># 指明形参名可乱序</span></span><br><span class="line">fun(<span class="number">1</span>, b=<span class="number">2</span>) <span class="comment"># 可行</span></span><br><span class="line">fun(<span class="number">1</span>, a=<span class="number">2</span>) <span class="comment"># 这样调用出错</span></span><br><span class="line">fun(a=<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 同样出错</span></span><br></pre></td></tr></table></figure></p>
<h5 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h5><p>缺省参数有缺省值。除了顺序在关键字参数后以及有缺省值外，与关键字参数基本相同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b=<span class="number">2</span>)</span>:</span>  <span class="comment"># b 为缺省参数</span></span><br><span class="line">    <span class="keyword">print</span> a, b</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h5><p>参数个数不定，形参最终得到元组，调用时可不传，一个个传递或传一个元组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, *b)</span>:</span> <span class="comment"># b 为变长参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">        <span class="keyword">print</span> a + i</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fun(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 用元组传递变长参数，加星号，称作解包</span></span><br><span class="line">fun(<span class="number">1</span>)  <span class="comment"># 不传或解包空元组都可行</span></span><br></pre></td></tr></table></figure></p>
<h5 id="关键字变长参数"><a href="#关键字变长参数" class="headerlink" title="关键字变长参数"></a>关键字变长参数</h5><p>参数个数不定，而且必须指明关键字。形参最终得到字典，与变长参数类似，调用时可不传，一个个传递或传一个字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():    </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"get "</span> + k + <span class="string">"="</span> + str(v)</span><br><span class="line">fun(a=<span class="number">1</span>, s=<span class="string">"hi"</span>)</span><br><span class="line">fun(**&#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"s"</span>: <span class="string">"hi"</span>&#125;)  <span class="comment"># 字典解包，注意关键字必须为字符串</span></span><br></pre></td></tr></table></figure></p>
<h5 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b=<span class="number">1</span>, *c, **d)</span>:</span> <span class="comment"># 函数定义时形参须根据类型按序定义</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d1=<span class="number">4</span>) <span class="comment"># 函数调用时也根据类型按序传入</span></span><br></pre></td></tr></table></figure>
<h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul>
<li>元素不能改变</li>
</ul>
<h4 id="False"><a href="#False" class="headerlink" title="False"></a>False</h4><p>判断语句中None,False,空字符串””,0,空列表[],空字典{},空元组()都相当于False</p>
<h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install virtualenv</span><br><span class="line"><span class="comment"># 创建虚拟环境，python3，无已安装包</span></span><br><span class="line">virtualenv -p python3 --no-site-packages venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate <span class="comment"># 激活</span></span><br><span class="line">pip freeze &gt; requirement <span class="comment"># pip freeze</span></span><br><span class="line">deactivate <span class="comment"># 退出虚拟环境</span></span><br></pre></td></tr></table></figure>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<h4 id="简单文件读写"><a href="#简单文件读写" class="headerlink" title="简单文件读写"></a>简单文件读写</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">col = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_path.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> df:</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> df:</span><br><span class="line">      tmp = line.strip().split(<span class="string">','</span>)</span><br><span class="line">      col.append(int(tmp[<span class="number">3</span>])) <span class="comment"># 读取第4列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'out_path'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> df: <span class="comment"># 'a' 追加</span></span><br><span class="line">  <span class="keyword">for</span> val <span class="keyword">in</span> col:</span><br><span class="line">    df.write(<span class="string">"%d\n"</span> % val)</span><br></pre></td></tr></table></figure>
<h4 id="在控制台运行源文件"><a href="#在控制台运行源文件" class="headerlink" title="在控制台运行源文件"></a>在控制台运行源文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execfile(<span class="string">'python_code.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="错误及解决办法"><a href="#错误及解决办法" class="headerlink" title="错误及解决办法"></a>错误及解决办法</h3><h4 id="pip安装出现SOCKS支持问题"><a href="#pip安装出现SOCKS支持问题" class="headerlink" title="pip安装出现SOCKS支持问题"></a>pip安装出现SOCKS支持问题</h4><p>报错<code>Missing dependencies for SOCKS support</code>。在Ubuntu下，用<code>unset all_proxy &amp;&amp; unset ALL_PROXY</code>命令解除代理设置。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/C-Cpp-cheatSheet/" itemprop="url">
                  C/Cpp 杂记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-03T10:47:21+08:00" content="2016-06-03">
              2016-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="简单文件读写"><a href="#简单文件读写" class="headerlink" title="简单文件读写"></a>简单文件读写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ifstream in;</span><br><span class="line">in.open(<span class="string">"file_path"</span>);</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span>(in &gt;&gt; k)  <span class="comment">// 读取 int 型数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">ofstream out;</span><br><span class="line">out.open(<span class="string">"out_path"</span>, ios::app); <span class="comment">// app模式追加，默认覆写</span></span><br><span class="line">out &lt;&lt; ‘hello world’ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><h4 id="循环计数器与-运算符"><a href="#循环计数器与-运算符" class="headerlink" title="循环计数器与 ++ 运算符"></a>循环计数器与 ++ 运算符</h4><p>考虑 while 和 do 计数循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(++i &lt; <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"while: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// i 不会被打印</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"do: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// i 被打印2次</span></span><br><span class="line">&#125;<span class="keyword">while</span>(i++ &lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里计数器 i 不能正常工作（打印一次），应该将计数器更新放在循环体避免失误，使用标准的 for 循环最好。</p>
<h4 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// 结构标记声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span> <span class="title">var_name</span>;</span> <span class="comment">// 结构变量声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125; var_name; <span class="comment">// 结构标记与变量同时声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125; struct_type, *p_struct_type;  <span class="comment">// 结构typedef名声明</span></span><br><span class="line">struct_type var_name; <span class="comment">// 结构变量声明</span></span><br><span class="line">p_struct_type var_name; <span class="comment">// 结构指针变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125; struct_type, *p_struct_type;  <span class="comment">// 结构标记与typedef名同时声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *PNode; <span class="comment">// 链表结点结构体典型声明</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/31/ML-MLT-1-dualSVM/" itemprop="url">
                  机器学习技法第二课——Dual Support Vector Machine
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-31T10:49:11+08:00" content="2016-05-31">
              2016-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第二课——Dual Support Vector Machine——的课堂笔记，有关 SVM 公式推导。</p>
<p>给定原公式：<br>$$<br>\frac{1}{2}\min_{b, \mathbf{w}} \mathbf{w^T w} \\<br>s.t. \ y_n(\mathbf{w^T \mathbf{x_n}} + b) \ge 1<br>$$<br>（为简化求解，公式与前次笔记稍有不同，但等价）这节课做了一系列的变换，最终有什么效果呢？</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/05/25/ML-MLT-0-deductionSVM/" title="linear SVM">linear SVM</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0" target="_blank" rel="noopener">拉格朗日乘数</a></li>
<li><a href="http://www.cnblogs.com/90zeng/p/Lagrange_duality.html" target="_blank" rel="noopener">简易解说拉格朗日对偶（Lagrange duality）</a></li>
<li><a href="http://xiaoyc.com/duality-theory-for-optimization/" target="_blank" rel="noopener">优化问题中的对偶性理论</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/202_handout.pdf" target="_blank" rel="noopener">课件</a></li>
</ul>
<h3 id="拉格朗日乘数法"><a href="#拉格朗日乘数法" class="headerlink" title="拉格朗日乘数法"></a>拉格朗日乘数法</h3><p>拉格朗日乘数法可以把限制条件和目标函数结合成一个整体。原公式整合成：<br>$$<br>L(b, \mathbf{w}, \alpha) = \frac{1}{2} \mathbf{w^T w} + \sum_{n=1}^{N}\alpha_n(1 - y_n(\mathbf{w^T \mathbf{x<em>n}} + b))<br>$$<br>SVM 求解公式变为：<br>$$<br>\min</em>{b,\mathbf{w}} (\max_{all\ \alpha<em>n \ge 0}L(b, \mathbf{w}, \alpha)) = \min</em>{b, \mathbf{w}}(\infty\ if\ violate;\ \mathbf{w^T w}\ if\ feasible)<br>$$</p>
<h3 id="拉格朗日对偶问题"><a href="#拉格朗日对偶问题" class="headerlink" title="拉格朗日对偶问题"></a>拉格朗日对偶问题</h3><p>利用对偶问题，对上步的求解公式取下限：<br>$$<br>\min<em>{b,\mathbf{w}} (\max</em>{all\ \alpha<em>n \ge 0}L(b, \mathbf{w}, \alpha)) \ge \max</em>{all\ \alpha’<em>n \ge 0} (\min</em>{b,\mathbf{w}} L(b, \mathbf{w}, \alpha’))<br>$$<br>至于为何成立我没有细究，只能说这符合直觉。因为，考虑 $L(b, \mathbf{w}, \alpha)$ 为一个波动的函数，视 $\max$ 为取波峰， $\min$ 取波谷，那么从波峰中最小的应该不小于波谷中最大的。</p>
<p>有证明表示，对拉格朗日对偶问题，如果满足 <strong><em>强对偶</em></strong> 的三个条件，原始函数为凸函数、原始问题可解、原始限制条件是线性的，就可以在上式中取等，而 SVM 刚好满足。 : P</p>
<h3 id="关于-alpha-函数"><a href="#关于-alpha-函数" class="headerlink" title="关于 $\alpha$ 函数"></a>关于 $\alpha$ 函数</h3><p>接下来对求解公式做2步“简化”，使之成为仅关于 $\alpha$ 的函数。</p>
<p><strong><em>去 $b$：</em></strong>  考虑在极值点，变量的梯度都应该为 $0$，所以 $b$ 的梯度<br>$$-\sum_{n=1}^N \alpha_n y<em>n = 0$$<br>把该式置于条件中并化简，得到求解公式等价式：<br>$$<br>\max</em>{\alpha<em>n} \min</em>\mathbf{w}(\frac{1}{2} \mathbf{w^T w} + \sum_{n=1}^{N}\alpha_n(1 - y_n \mathbf{w^T \mathbf{x_n}})) \\<br>s.t.\ all\ \alpha<em>n \ge 0,\ \sum</em>{n=1}^N \alpha_n y_n = 0<br>$$</p>
<p><strong><em>去 $\mathbf{w}$：</em></strong>　$\mathbf{w}$ 的梯度<br>$$\mathbf{w}<em>i - \sum</em>{n=1}^N \alpha_n y<em>n x</em>{n,i} = 0 \\<br>\Rightarrow \mathbf{w} = \sum_{n=1}^{N} \alpha_n y_n \mathbf{x<em>n}$$<br>把该式置于条件中并经过化简，得到最终的求解公式：<br>$$<br>\max</em>{\alpha<em>n} (-\frac{1}{2}|\sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x<em>n}|^2 + \sum</em>{n=1}^{N}\alpha_n) \\<br>s.t.\ all\ \alpha<em>n \ge 0,\ \sum</em>{n=1}^N \alpha_n y<em>n = 0,\ \mathbf{w} = \sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x_n}<br>$$<br>注意其中的 $\mathbf{x_n}$ 及其求和均为向量，原本的求最小因为消去 $b, \mathbf{w}$ 而除去。</p>
<h3 id="KKT-条件"><a href="#KKT-条件" class="headerlink" title="KKT 条件"></a>KKT 条件</h3><p>对凸优化问题，KKT 条件是一组解成为最优解的充分必要条件。（见<a href="http://xiaoyc.com/duality-theory-for-optimization/" target="_blank" rel="noopener">“优化问题中的对偶性理论”</a>）而 SVM 求解原式和对偶式（强对偶）都有最优解，所以最优解满足 KKT 条件。<br>这其中有 2 个条件可以用于从最最优 $\alpha$ 中解出最做优 $b, \mathbf{w}$<br>$$<br>\mathbf{w} = \sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n} \\<br>\alpha_n(1 - y_n(\mathbf{w^T \mathbf{x_n}} + b)) = 0<br>$$</p>
<h3 id="二次规划求解"><a href="#二次规划求解" class="headerlink" title="二次规划求解"></a>二次规划求解</h3><p>与上一课一样，因为求解问题是一个二次规划问题，所以可以借助相关的工具。在此之前，需要做一些变换。</p>
<p><strong><em>最大化变最小化</em></strong>　　最优化工具往往求最小值。求解公式取相反数：<br>$$<br>\min_{\alpha<em>n} (\frac{1}{2}|\sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x<em>n}|^2 - \sum</em>{n=1}^{N}\alpha_n) \\<br>$$</p>
<p><strong><em>隐藏 $\mathbf{w}$ 的限制条件</em></strong>　　使公式完全变为关于 $\alpha$ 的函数，剩下的 $x, y$ 都是已知量<br>$$<br>s.t.\ all\ \alpha<em>n \ge 0,\ \sum</em>{n=1}^N \alpha_n y_n = 0<br>$$</p>
<p><strong><em>展露二次项系数</em></strong>　　求解公式中二次项系数不易发现，做拆分：<br>$$|\sum_{n=1}^{N} \alpha_n y_n \mathbf{x<em>n}|^2 \\<br>=(\sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x<em>n})^\mathbf{T}(\sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x<em>n})<br>=(\sum</em>{m=1}^{N} \alpha_m y_m \mathbf{x<em>m^T})(\sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x<em>n})\\<br>=\sum</em>{m=1}^{N} \sum_{n=1}^{N} y_m \mathbf{x_m^T}  y_n \mathbf{x_n} \alpha_m \alpha_n<br>$$<br>注意该式原始是2个（由多个向量求和得到的）向量的内积，最后一步变换使用了向量的分配律。可见，二次项 $\alpha_m \alpha_n$ 的系数为 $y_m \mathbf{x_m^T}  y_n \mathbf{x_n}$。</p>
<p>最后给出 <strong><em>完整公式</em></strong>：<br>$$<br>\min_{\alpha<em>n} (\frac{1}{2}\sum</em>{m=1}^{N} \sum_{n=1}^{N} y_m \mathbf{x_m^T}  y_n \mathbf{x_n} \alpha_m \alpha<em>n - \sum</em>{n=1}^{N}\alpha_n) \\<br>s.t.\ all\ \alpha<em>n \ge 0,\ \sum</em>{n=1}^N \alpha_n y<em>n = 0<br>$$<br>利用二次规划工具解决该问题，解出 $\alpha$ 后，再利用 KKT 公式的2个条件，解出 $\mathbf{w}, b$:<br>$$<br>\mathbf{w} = \sum</em>{n=1}^{N} \alpha_n y_n \mathbf{x_n} \\<br>b = y_n - \mathbf{w^T \mathbf{x_n}}\ ,\  s.t.\ \alpha_n \ne 0<br>$$</p>
<p>值得注意的是，二次项系数矩阵是 $N \times N$ 的大型矩阵，而且并非上节课的对角矩阵，需要专为 SVM 设计的二次规划求解工具。</p>
<h3 id="SV-与后续"><a href="#SV-与后续" class="headerlink" title="SV 与后续"></a>SV 与后续</h3><p>很明显，利用 $\alpha$ 求解 $\mathbf{w}, b$ 时，如果 $\alpha_i$ 为0，对求解没有影响。也就是说，对应 $\alpha_i = 0$ 的向量（数据点）对求解没有影响。联系上节课，即对应 $\alpha_i \gt 0$ 的向量为支持向量（SV）。</p>
<p>课程中对原始向量 $\mathbf{x}$ 做了向N维向量 $\mathbf{z}$ 的映射，$\mathbf{x}$ 替换成 $\mathbf{z}$ 后对推导没有影响。而这节课的变换似乎没有简化求解，至于为何目的，只有后续揭晓了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/25/ML-MLT-0-deductionSVM/" itemprop="url">
                  机器学习技法第一课——Linear Support Vector Machine
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-25T13:01:10+08:00" content="2016-05-25">
              2016-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第一课——Linear Support Vector Machine——的课堂笔记，有关 SVM 公式推导。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/05/23/Math-LinAlg-hyperplane/" title="超平面">超平面</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/201_handout.pdf" target="_blank" rel="noopener">课件</a></li>
</ul>
<h3 id="（单层）感知器"><a href="#（单层）感知器" class="headerlink" title="（单层）感知器"></a>（单层）感知器</h3><p>感知器 (Perceptron) 利用超平面<br>$$\mathbf{w} \cdot \mathbf{x} = b $$<br>进行二元分类。其中，$\mathbf{x} = (x_1, x_2, …, x_n)$，$\mathbf{w} = (w_1, w_2, …, w_n)$。</p>
<p>一个数据 $(\mathbf{x},y)$ 中，$\mathbf{x}$ 作为输入，一个特征向量，可代表一个实体，而输出 $y \in {-1, 1}$ 则标记该实体的类别。Perceptron 希望找到一个超平面，即确定参数 $\mathbf{w}, b$， 能对一组数据 ${(\mathbf{x_1}, y_1), (\mathbf{x_2}, y_2),…,(\mathbf{x_n}, y_n),}$ 进行分类，使得对每组 $(\mathbf{x}, y)$ 都有：当 $y &gt; 0$ 时，$\mathbf{w} \cdot \mathbf{x} &gt; b$, 否则，$\mathbf{w} \cdot \mathbf{x} &lt; b$。</p>
<p>例子，考虑输入为二维向量，每个数据表现为一个点，而超平面视作一条直线，Perceptron 所做的是，对多个数据点，找到一条直线将有不同标记（-1或1）的点分开。</p>
<h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>SVM 在 Perceptron 上更进一步，不仅要求能够找到一个超平面，而且要求这个超平面能能够尽量容忍误差。就 <em>Perceptron</em> 一节所举例子，SVM 要求该直线尽可能远离数据点，使得如果数据点因为误差而偏移，该直线也可能正确分类。</p>
<p>这可以理解成要求向量到超平面的距离尽可能大。在 <a href="/2016/05/23/Math-LinAlg-hyperplane/" title="超平面">超平面</a> 的 <em>点与超平面距离与 SVM</em> 一节中已经说明距离可以表示为<br>$$<br>d = \left| \frac{\mathbf{w \cdot x}}{\mathbf{|w|}} - \frac{b}{\mathbf{|w|}} \right| = \frac {1} {|\mathbf{w}|} |\mathbf{w \cdot x} - b|<br>$$<br>这时，目标可以转换成求使“最小的 d” “最大” 的 $\mathbf{w}, b$，“最小的d”指所有向量与某组 $\mathbf{w}, b$ 所确定的超平面的距离的最小值，“最大” 则指所有 $\mathbf{w}, b$ 组各自对应的 “最小的 d ” 中最大的。翻译成符号：<br>$$<br>\max_{b, \mathbf{w}} margin(b, \mathbf{w})  \\<br>subject\ to \ every\ y_n(\mathbf{w^T x<em>n} - b) &gt; 0  \\<br>margin(b, \mathbf{w}) = \min</em>{n=1,..,N} \frac {1}{|\mathbf{w}|} |\mathbf{w^T x_n} - b|<br>$$<br>其中，margin 可理解成距离，subject to 表示限制。即要求在可分类的情况下，求解出每组 $(b, \mathbf{w})$ 最小的距离，再选取其中最大的。注：$\min$ 内部，$n$ 作为变量，而 $\max$ 内部， $\mathbf{w}, b$ 作为变量。</p>
<p>课程中将其转换为二次规划（Quadratic programming）问题求解。</p>
<p><strong><em>去绝对值</em></strong>，$|\mathbf{w^T x_n} - b|$ 转换成 $y_n(\mathbf{w^T x_n} - b)$。</p>
<p><strong><em>令 $y_n(\mathbf{w^T x_n} - b)=1$</em></strong>（可以等于任一大于0常数），考虑到<br>$\mathbf{w}, b$ 作为求解变量可以乘以一个常数 k 进行放缩同时保持超平面不变，而 $|\mathbf{w}|$ 会抵消 k 带来的影响并保持 margin 不变，所以这步变换与原式等价。这使得<br>$$margin = \min_{n=1,..,N} \frac {1}{|\mathbf{w}|} $$<br>而且，这可以去除限制 $y_n(\mathbf{w^T x<em>n} - b) &gt; 0$，变换为：<br>$$<br>\max</em>{b, \mathbf{w}} \frac {1}{|\mathbf{w}|} \\<br>subject\ to \ [\min_{n=1,..,N} y_n(\mathbf{w^T x_n} - b)]=1<br>$$</p>
<p><strong><em>令 $y_n(\mathbf{w^T x_n} - b) \ge 1$</em></strong>，要求对于所有的 $n$ 都成立（上步仅要求最小值处成立）。这是合乎情理的，因为对于被放缩的某组 $\mathbf{w}, b$，距离最小值为1，则该组所有值都应不小于1。好处是限制条件不必做最小化操作。课程中也给出证明，说明此步与原式等价，在此不赘述。</p>
<p><strong><em>求最大值变为求最小值，去掉倒数与绝对值</em></strong>。最终变换成一个所谓简单的二次规划问题为<br>$$<br>\min_{b, \mathbf{w}} \mathbf{w^T w} \\<br>subject\ to \ y_n(\mathbf{w^T x_n} - b) \ge 1<br>$$</p>
<h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p>所谓支持向量，即距离最佳超平面最近的向量。它们“支持”了最佳超平面，而丢失其他向量对最佳超平面没有影响。对最佳 $(\mathbf{w}, b)$ 支持向量满足：<br>$$y(\mathbf{w^T x} - b) = 1$$</p>
<h3 id="更强容错能力"><a href="#更强容错能力" class="headerlink" title="更强容错能力"></a>更强容错能力</h3><p>直觉上认为 SVM 有更强的容错能力。课程中比较了一般正则仳与 SVM：<br>|       | minimize |  constraint|<br>|:—–:|:—–:|:——-:|<br>regularization |  $E<em>{in}$ | $\mathbf{w^T w} \le C$<br>SVM            |  $\mathbf{w^T w}$  |   $E</em>{in} = 0$ [and more]<br>可看出 SVM 实际上做了与正则化相似的工作，而正则化能提高模型的容错能力。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/25/Math-Game-5initRules/" itemprop="url">
                  耶鲁博弈论-5个入门结论-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-25T12:34:03+08:00" content="2016-05-25">
              2016-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>链接：<a href="http://open.163.com/special/gametheory/" target="_blank" rel="noopener">耶鲁大学公开课-博弈论</a></p>
<h3 id="5个入门结论"><a href="#5个入门结论" class="headerlink" title="5个入门结论"></a>5个入门结论</h3><ul>
<li>Do not play a strictly dominated strategy.</li>
<li>Rational choose can lead to outcomes suck.</li>
<li>You can’t get what you want, till you know what you want.</li>
<li>Put yourself in others’ shoes and try to figure out what they’ll do.</li>
<li>Yale students are evil.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/23/Math-LinAlg-hyperplane/" itemprop="url">
                  超平面
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-23T20:30:11+08:00" content="2016-05-23">
              2016-05-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考： <a href="/2016/09/28/Math-LinAlg-analyticGeometry/" title="空间解析几何">空间解析几何</a></p>
<p>在 n 维空间中，满足方程<br>$$a_1 x_1 + a_2 x_2 + … + a_n x_n = b $$<br>的向量 $(x_1, x_2,…,x_n)$ 构成的空间称为 <strong>超平面</strong>。 例如，立体空间中它表示平面，平面中它表示直线。表面上有 n 个自由维度，实际上当 $(n-1)$ 个维度值确定时，剩下的一个维度也确定了。</p>
<h4 id="参数的取值范围与-Perceptron"><a href="#参数的取值范围与-Perceptron" class="headerlink" title="参数的取值范围与 Perceptron"></a>参数的取值范围与 Perceptron</h4><p>单层感知器（Perceptron）利用超平面分类数据。输入训练数据为向量 $\mathbf{x} = (x_1, x_2,…, x_n)$， 其目标是训练出权重向量 $\mathbf{w} = (w_1, w_2,…, w_n)$ 与偏值 $b$， 使得所有满足 $\mathbf{w}\cdot \mathbf{x}\ge b$ 的数据同为一类，而满足 $\mathbf{w}\cdot \mathbf{x}&lt; b$ 的数据同为另一类。形象地理解就是，给定 n 维空间的许多点，分为两种类型，要求找到一个超平面，将这两种类型的点分开。再形象点，在二维空间中，有许多红点和蓝点，Perceptron 需要划一条直线将红点蓝点分开。（当然，Perceptron 往往不能对数据完全正确分类，所以有后续的处理。这里只是理想情况）</p>
<p>值得注意的是，偏值 $b$ 容易被误认为无需训练，直接设为定值就行（比如零）。实际上，将权重向量的任何一个元素及偏值 $b$ 固定为常量，都会导致（ $\mathbf{w}, b$ ）所能表示的超平面减少，从而导致分类的能力下降。可以参考平面下直线的表达式： $ax+by=c$ ，如果固定 $c=0$， 该直线必定过原点，不能表示许多不过原点的直线。</p>
<h4 id="点到超平面距离与-SVM"><a href="#点到超平面距离与-SVM" class="headerlink" title="点到超平面距离与 SVM"></a>点到超平面距离与 SVM</h4><p>支持向量机（SVM）也是利用超平面分类向量的，它关注的是点与超平面的距离。</p>
<p>已知超平面的法向量 $\mathbf{w}=(w_1,w_2,…,w_n)$ 和数 $b$， 超平面表示为：</p>
<p>$$ \mathbf{w}\cdot\mathbf{x} + b=0 $$</p>
<p>$\mathbf{x}= (x_1, x_2,…, x_n)$ 表示超平面上的任意一点。设 $\mathbf{y}_0= (y_1, y_2,…, y_n)$ 为超平面上一点，则有 $\mathbf{w}\cdot\mathbf{y}_0 = -b$。可得点 $\mathbf{s}= (s_1, s_2,…, s_n)$ 与超平面的距离 $d$：</p>
<p>$$ d=\left| \frac{\mathbf{w}\cdot(\mathbf{s}_0 - \mathbf{y}_0)}{||\mathbf{w}||} \right|=\left| \frac{\mathbf{w}\cdot\mathbf{s}_0 + b}{||\mathbf{w}||} \right| $$</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Blunt" />
          <p class="site-author-name" itemprop="name">Blunt</p>
          <p class="site-description motion-element" itemprop="description">email：summer15y@163.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">68</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Blunt</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

  

  


</body>
</html>
