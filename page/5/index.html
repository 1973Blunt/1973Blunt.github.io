<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="email：summer15y@163.com">
<meta property="og:type" content="website">
<meta property="og:title" content="HotSummer">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="HotSummer">
<meta property="og:description" content="email：summer15y@163.com">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HotSummer">
<meta name="twitter:description" content="email：summer15y@163.com">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>





  <title> HotSummer </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">HotSummer</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/ML-MLT-6-blendingBagging/" itemprop="url">
                  机器学习技法第七课——Blending and Bagging
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T11:03:24+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是本人学习林轩田老师的机器学习技法第七课——Blending and Bagging。第七至第十一课学习 ML 中的各种集成学习（<a href="https://en.wikipedia.org/wiki/Ensemble_learning" target="_blank" rel="noopener">Ensemble Learning</a>）算法。简单地讲，Ensemble 集成各种模型为一个最终模型。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/207_handout.pdf" target="_blank" rel="noopener">课件</a></li>
<li><a href="http://mlwave.com/kaggle-ensembling-guide/" target="_blank" rel="noopener">Kaggle Ensembling Guide</a></li>
<li><a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" target="_blank" rel="noopener">Understanding the Bias-Variance Tradeoff</a></li>
<li><a href="/2016/08/12/ML-validation/" title="模型验证">模型验证</a></li>
<li><a href="/2016/08/14/Math-PrStats-bootstrapping/" title="Bootstrapping">Bootstrapping</a></li>
</ul>
<h3 id="误差的-bias-和-variance">误差的 bias 和 variance</h3>
<p>在此文——<a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" target="_blank" rel="noopener">Understanding the Bias-Variance Tradeoff</a>——中有介绍，同种模型训练由于参数、抽样等不同，得到的模型的误差会有一定的随机性，所以有了模型误差的 bias 与 variance 的概念。</p>
<p>简单地讲，bias 指误差的期望，即模型的预测偏离正确值的期望。而 variance 即误差的方差，衡量模型误差的分散程度。这两个值当然是越小越好。</p>
<h3 id="blending">Blending</h3>
<p>Blending 是十分自然的集成方法。简单地讲，就是将各模型的预测作为数据进行回归或分类训练将其结合。训练过程如下：</p>
<ol type="1">
<li>将训练集 <span class="math inline">\(D_{train}\)</span> 分为 <span class="math inline">\(D_{train}^-\)</span> 和 <span class="math inline">\(D_{val}\)</span>，每条数据可表示为 <span class="math inline">\((x_1, x_2,...,y)\)</span></li>
<li>在 <span class="math inline">\(D_{train}^-\)</span> 上，训练出各模型 <span class="math inline">\(G^-=(g_1^-(\mathbf{x}), g_2^-(\mathbf{x}), g_3^-(\mathbf{x}),...)\)</span></li>
<li>在 <span class="math inline">\(D_{val}\)</span>，各模型分别做出预测，组合成新的数据集 <span class="math inline">\(D_{pred}\)</span>，每条数据可表示为 <span class="math inline">\(\Phi(\mathbf{x}) = (g_1(\mathbf{x}),g_2(\mathbf{x}),g_3(\mathbf{x}),...,y)\)</span></li>
<li>在 <span class="math inline">\(D_{train}\)</span> 上，训练出各模型 <span class="math inline">\(G=(g_1(\mathbf{x}), g_2(\mathbf{x}), g_3(\mathbf{x}),...)\)</span></li>
<li>在 <span class="math inline">\(D_{pred}\)</span> 上，进行分类或回归训练，得到 Blending 模型参数，结合 <span class="math inline">\(G\)</span> 得到最终模型</li>
</ol>
<p>(注：<span class="math inline">\(x_i\)</span> 表示数值，加粗 <span class="math inline">\(\mathbf{x}\)</span> 表示一个向量，<span class="math inline">\(\mathbf{x}=(x_1, x_2,...,x_n)\)</span>) 进行测试时，先用 <span class="math inline">\(G\)</span> 做出预测作为输入代入 Blending 模型得到最终预测值。这里有2个问题。</p>
<p>为什么要把 <span class="math inline">\(D_{train}\)</span> 分为 <span class="math inline">\(D_{train}^-\)</span> 和 <span class="math inline">\(D_{val}\)</span>，而不直接在训练集上做训练同时做预测，然后作为 Blending 的训练数据？因为训练得到的模型已经“知道了”其训练数据，在其训练数据上做预测不能反映其预测能力的真实情况，会付出复杂度方面的代价。所以，跟模型选择中所做的验证一样，需要使用模型未知的数据做验证。</p>
<p>为什么使用 <span class="math inline">\(G\)</span> 而非 <span class="math inline">\(G^-\)</span> 得到最终模型？<span class="math inline">\(G\)</span> 在 <span class="math inline">\(D_{train}\)</span> 上训练得到，比在更小的训练集 <span class="math inline">\(D_{train}^-\)</span> 得到的 <span class="math inline">\(G^-\)</span> 更优。</p>
<p>在课上，老师证明了各模型 <span class="math inline">\(E_{out}\)</span> 的期望大于 Blending 模型 <span class="math inline">\(E_{out}\)</span> 的期望，也就是说，Blending 模型的预测优于各模型的“平均水平”。（实际上只证明了 uniform blending，在此不细究）</p>
<h4 id="stacking">Stacking</h4>
<p>根据博文 <a href="http://mlwave.com/kaggle-ensembling-guide/" target="_blank" rel="noopener">Kaggle Ensembling Guide</a>，Blending 可视为 Stacking 的简化。（Stacking 远早于 Blending 被提出）现在很多研究者视两者等同。</p>
<p>可以很容易发现，Blending 的一至三步与 <a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E9%A9%97%E8%AD%89#Holdout_.E9.A9.97.E8.AD.89" target="_blank" rel="noopener">Hold-out Validation</a> 的步骤是相同的。存在多个模型时，常使用验证来选择模型，而 Hold-out 就是其中最基本的一种。而 Stacking 使用 <a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E9%A9%97%E8%AD%89#Holdout_.E9.A9.97.E8.AD.89" target="_blank" rel="noopener">Cross-Validation</a>。</p>
<p>在 <a href="/2016/08/12/ML-validation/" title="模型验证">模型验证</a> 中， Cross-Validation 虽然比使用 Hold-out Validation 复杂，但是 Stacking 得到的 <span class="math inline">\(D_{pred}\)</span> 与 <span class="math inline">\(D_{train}\)</span> 数据量相等，而 Blending 得到的 <span class="math inline">\(D_{pred}\)</span> 与 <span class="math inline">\(D_{val}\)</span> （一般取 <span class="math inline">\(D_{train}\)</span> 的10%）等量，较小。</p>
<h3 id="bagging">Bagging</h3>
<p>又称 Bootstrap Aggregation, 基于统计学上的 <strong><a href="/2016/08/14/Math-PrStats-bootstrapping/" title="Bootstrapping">Bootstrapping</a></strong> 方法。简单地讲，就是从一个样本集中有放回地抽样得到多个样本集。</p>
<p>Bagging 利用 Bootstrapping 的原理，在训练集 <span class="math inline">\(D_{train}\)</span> 上有放回地抽样得到多个训练集 <span class="math inline">\(D_1^-\)</span>, <span class="math inline">\(D_2^-\)</span>, <span class="math inline">\(D_3^-\)</span>,…，然后用抽取的训练集训练模型，由于抽取得到的训练集各不相同，得到的模型也各不相同（除非训练不受训练集影响，那还训练干嘛）。在预测时，取所有模型预测的均值。</p>
<p>Bagging 能够降低模型预测的 varaince 误差，特别适用于对样本敏感的波动比较大的模型。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/10/ML-MLT-5-supportVectorRegression/" itemprop="url">
                  机器学习技法第六课——Support Vector Regression
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-10T16:44:46+08:00" content="2016-07-10">
              2016-07-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是本人学习林轩田老师的机器学习技法第六课——Support Vector Regression——的课堂笔记。</p>
<p>这节课介绍两个模型，与之前的 SVM 不同，都采用二次误差，一个是“kernel ridge regression”，另一个比较重要，是“Support Vector Regression”。最后，针对“机器学习基石”及本课程所讲的分类方法做一个总结。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/206_handout.pdf" target="_blank" rel="noopener">课件</a></li>
<li><a href="/2016/06/26/ML-MLT-4-kernelLogisticRegression/" title="Kernel Logistic Regression">Kernel Logistic Regression</a></li>
<li><a href="http://blog.csdn.net/google19890102/article/details/27228279" target="_blank" rel="noopener">岭回归</a></li>
<li><a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a></li>
</ul>
<h3 id="kernel-ridge-regression">Kernel Ridge Regression</h3>
<p>ridge regression，即<a href="http://blog.csdn.net/google19890102/article/details/27228279" target="_blank" rel="noopener">岭回归</a>，简单地讲，是“在平方误差的基础上增加 L2 正则项的回归”。以下是基本公式，这部分目标是将其 kernel 化。 <span class="math display">\[  \min_{\mathbf{w}} \frac{\lambda}{N}\mathbf{w^Tw} + \frac{1}{N} \sum_{n=1}^{N}{ (y_n - w^T z_n)^2 }
\]</span></p>
<p>在上节课“”中的“Kernel Logistic Regression”一节，已经讲过“带 L2 正则化的线性模型”可以被 kernel 化，而且 <span class="math inline">\(\mathbf{w}\)</span> 可以被 <span class="math inline">\(\mathbf{z}\)</span> 线性表示，即 <span class="math inline">\(\mathbf{w} = \sum \beta_n z_n\)</span>。</p>
<p>因为这部分推导与“Kernel Logistic Regression”的推导相似，在此给出结果： <span class="math display">\[  \min_{\beta} { \frac{\lambda}{N} \sum_{n=1}^{N}\sum_{n=1}^{M} \beta_n \beta_m K(\mathbf{x_n, x_m})
 +\frac{1}{N} \sum_{n=1}^{N}{ ( y_n - \sum_{m=1}^N {\beta_m K(\mathbf{x_m, x_n})} )^2 }}
\]</span></p>
<p>接下来求解。首先矩阵化，代入 <span class="math inline">\(\mathbf{\beta, y}\)</span> 列矩阵，<span class="math inline">\(\mathbf{K_{n \times n}}\)</span> 矩阵，<span class="math inline">\(\mathbf{K_{m,n}} = K(\mathbf(x_m, x_n)\)</span>： <span class="math display">\[  \min_{\beta} {\frac{\lambda}{N} \mathbf{\beta^T K \beta} + \frac{1}{N} ( \beta^T K \beta K - 2 \beta^T K^Ty + y^T y )}
\]</span></p>
<p>求导，梯度为： <span class="math display">\[ \nabla = \frac{2}{N} \mathbf{K^T}( (\lambda \mathbf{I} + \mathbf{K}) \mathbf{\beta} - \mathbf{y} )
\]</span></p>
<p>令梯度为 0, 则解得： <span class="math display">\[  \mathbf{\beta} = (\lambda \mathbf{I} + \mathbf{K})^{-1} \mathbf{y}
\]</span></p>
<p>推导过程中省略了许多步骤 :-P。需要注意的是，该求解方法时间复杂度为 <span class="math inline">\(O(N^3)\)</span>，而且 <span class="math inline">\(\beta\)</span> 内元素值多不为 0。课中讲到，用于分类的“Kernel Ridge Regression”被称作“least squares SVM (LSSVM)”。因为 <span class="math inline">\(\beta_n\)</span> 多数非 0，它求解得到的“Support Vector”非常多。</p>
<h3 id="support-vector-regression">Support Vector Regression</h3>
<p>“Support Vector Regression (SVR)”尝试避免“Kernel Ridge Regression”的“Support Vector” dense 问题，同时保留类似二次误差(least squares error)的形式。</p>
<p>相对于 SVM 的 <strong>hinge regression</strong>，Support Vector Regression 采用 <strong>tube regression</strong>（在上节课“”介绍过）。令 <span class="math inline">\(s=w^T z + b\)</span>，两者加上 <strong>squared error</strong> 的 error function 表达式为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">err type</th>
<th style="text-align: center;">function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">squared err</td>
<td style="text-align: center;"><span class="math inline">\((s-y)^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">tube err</td>
<td style="text-align: center;"><span class="math inline">\(\max(abs(s - y) - \epsilon,\; 0)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">hinge err</td>
<td style="text-align: center;"><span class="math inline">\(\max(1-ys,\; 0)\)</span></td>
</tr>
</tbody>
</table>
<p>（abs 取绝对值函数）很明显，squared err 与 tube err 的变化趋势相近，当 <span class="math inline">\(s \rightarrow +\infty\)</span>，<span class="math inline">\(err \rightarrow +\infty\)</span>，当 <span class="math inline">\(s \rightarrow -\infty\)</span>，<span class="math inline">\(err \rightarrow +\infty\)</span>。如果作图，两者都呈一个山谷状。</p>
<p>在 <a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a> 中，使用了 hinge error，在此将其替换成 tube error 重新推导。 <span class="math display">\[  \min_{b, \mathbf{w}} \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}{\max(0, |w^T z_n + b - y_n| - \epsilon)}
\]</span></p>
<p>首先，引入松弛变量 <span class="math inline">\(\xi_n^\bigwedge, \xi_n^\bigvee\)</span>，同时去掉绝对值： <span class="math display">\[  \min_{b,\mathbf{w},\xi_n^\bigwedge, \xi_n^\bigvee} \frac{1}{2}\mathbf{w^Tw} + C \sum{ (\xi_n^\bigwedge + \xi_n^\bigvee) } \\\\
s.t.\quad  -\epsilon - \xi_n^\bigvee \le y_n - w^T z_n - b \le \epsilon + \xi_n^\bigwedge \\\\
\xi_n^\bigwedge \ge 0,\quad \xi_n^\bigvee \ge 0
\]</span></p>
<p>之后，引入拉格朗日乘数 <span class="math inline">\(\alpha_n^\bigwedge, \alpha_n^\bigvee\)</span>，分别对应限制条件的上限与下限，又经过一系列求导、KKT 条件、化简等处理（参考“<a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a>” :-P），得到最终公式： <span class="math display">\[  \min  \frac{1}{2} \sum_{n=1}^{n}\sum_{m=1}^{n} (\alpha_n^\bigwedge - \alpha_n^\bigvee)(\alpha_m^\bigwedge - \alpha_m^\bigvee)K(x_n, x_m) + \sum_{n=1}^N( (\epsilon - y_n) \alpha_n^\bigwedge + (\epsilon ＋ y_n) \alpha_n^\bigvee) \\\\
s.t.\quad \sum(\alpha_n^\bigwedge - \alpha_n^\bigvee) = 0 \\\\
0 \le \alpha_n^\bigwedge \le C, 0 \le \alpha_n^\bigvee \le C
\]</span> 同样是 QP 问题，求解得出 <span class="math display">\[  \mathbf{w} = \sum(\alpha_n^\bigwedge - \alpha_n^\bigvee)\mathbf{z_n}
\]</span> Support Vector 为 <span class="math inline">\(\alpha_n^\bigwedge - \alpha_n^\bigvee \ne 0\)</span> 对应的数据点，SVR 保证了 SV 的稀疏性。</p>
<h3 id="分类器小结">分类器小结</h3>
<p>目前学习的（二）分类器，可以“线性的”与“kernel化的”，从 error function 看，可分为 “0/1 error”, “hinge error”, “squared/tube error”, “logistic error”。</p>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 25%">
<col style="width: 28%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">linear / kernel</th>
<th style="text-align: center;">0/1 or hinge error</th>
<th style="text-align: center;">squared/tube error</th>
<th style="text-align: center;">　logistic error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">linear</td>
<td style="text-align: center;">PLA/pocket</td>
<td style="text-align: center;">linear SVR</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">linear</td>
<td style="text-align: center;">linear soft-margin SVM</td>
<td style="text-align: center;">linear ridge regression</td>
<td style="text-align: center;">regularized logistic regression</td>
</tr>
<tr class="odd">
<td style="text-align: center;">kernel</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">kernel ridge regression</td>
<td style="text-align: center;">kernel regularized logistic regression</td>
</tr>
<tr class="even">
<td style="text-align: center;">kernel</td>
<td style="text-align: center;">SVM</td>
<td style="text-align: center;">SVR</td>
<td style="text-align: center;">probabilistic SVM</td>
</tr>
</tbody>
</table>
<p>其中第二、四行是最常用的，老师推荐了开源库 LIBLINEAR 与 LIBSVM。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/Math-Calculus-cheatSheet/" itemprop="url">
                  微积分笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-30T19:08:24+08:00" content="2016-06-30">
              2016-06-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="参考">参考</h3>
<ul>
<li>《微积分（第2版）（上册）》，傅英定 谢云荪 主编，高等教育出版社</li>
</ul>
<h3 id="微积分系列笔记">微积分系列笔记</h3>
<ul>
<li><a href="/2016/07/30/Math-Calculus-limit/" title="极限">极限</a></li>
<li><a href="/2016/07/30/Math-Calculus-derivation/" title="导数">导数</a></li>
<li><a href="/2016/07/30/Math-Calculus-indefiniteIntegration/" title="不定积分计算">不定积分计算</a></li>
<li><a href="/2016/07/30/Math-Calculus-derivationApplication/" title="导数应用">导数应用</a></li>
<li><a href="/2016/08/16/Math-Calculus-definiteIntegral/" title="定积分">定积分</a></li>
<li><a href="/2016/08/20/Math-Calculus-definiteIntegralApp/" title="定积分的应用">定积分的应用</a></li>
<li><a href="/2016/08/20/Math-Calculus-ordinaryDifferentialEq/" title="常微分方程">常微分方程</a></li>
<li><a href="/2016/09/13/Math-Calculus-multiIntegral/" title="重积分">重积分</a></li>
<li><a href="/2016/09/26/Math-Calculus-multiDerivat/" title="多元函数最值">多元函数最值</a></li>
</ul>
<h3 id="常见处理">常见处理</h3>
<h4 id="对-ex2-的积分">对 <span class="math inline">\(e^{x^2}\)</span> 的积分</h4>
<p>考虑正态分布</p>
<h4 id="根式常见处理">根式常见处理</h4>
<ul>
<li>平方</li>
<li>分子、分母有理化</li>
<li>换元</li>
</ul>
<h4 id="幂指函数处理">幂指函数处理</h4>
<ul>
<li>指数真底互换</li>
<li>取对数</li>
</ul>
<h4 id="乘法变加法">乘法变加法</h4>
<p>取对数</p>
<h4 id="积分被积变量">积分被积变量</h4>
<p>非被积变量被视为常数，即使是自变量，如 <span class="math inline">\(f(x) =x \int_a^x f(t) dt\)</span>， 也可以自由“出入”积分，如 <span class="math inline">\(f(x) = \int_a^x x f(t) dt\)</span></p>
<h4 id="变量不等式证明">2 变量不等式证明</h4>
<p>固定一个，变动另一个，即其中一个作为常数，另一个作为变量。另外，区间端点如 <span class="math inline">\(a, b\)</span>， 也可视为 2 个变量。</p>
<h4 id="无穷项数列和的极限">无穷项数列和的极限</h4>
<ul>
<li>夹逼准则</li>
<li>定积分定义</li>
<li>构造函数项无穷级数</li>
</ul>
<h4 id="不定积分">不定积分</h4>
<p>不定积分的定积分形式： <span class="math inline">\(\int f(x) dx = \int_0^x f(x) dx + C\)</span></p>
<h4 id="max-与-min-函数不等式">max 与 min 函数不等式</h4>
<ol type="1">
<li><span class="math inline">\(\max(a,b) &lt; c\)</span> 等价于 <span class="math inline">\(a &lt; c\; \&amp;\&amp; \; b &lt; c\)</span></li>
<li><span class="math inline">\(\min(a,b) &gt; c\)</span> 等价于 <span class="math inline">\(a &gt; c\; \&amp;\&amp; \; b &gt; c\)</span></li>
<li><span class="math inline">\(\max(a,b) &gt; c\)</span> 的逆命题是 <span class="math inline">\(\max(a,b) \le c\)</span>， <span class="math inline">\(\min\)</span> 函数同理</li>
</ol>
<h3 id="公式">公式</h3>
<h4 id="对数换底公式">对数换底公式</h4>
<p><span class="math display">\[\log_a b = \frac{\log_c b}{\log_c a}=\frac{\ln b}{\ln a}\]</span></p>
<h4 id="指数真底互换">指数真底互换</h4>
<p><span class="math display">\[x^y =a^{y\log_a x}= e^{y\ln{x}}\]</span></p>
<h4 id="求导公式">求导公式</h4>
<p><span class="math display">\[(x^a)&#39; = a x^{a-1}\]</span></p>
<p><span class="math display">\[(e^x)&#39; = e^x, \quad (a^x)&#39; = a^x \ln a\]</span></p>
<p><span class="math display">\[(\ln x)&#39; = \frac{1}{x}, \quad (\log_a x)&#39; = \frac{1}{x \ln a} \]</span></p>
<p><span class="math display">\[(\sin(x))&#39; = \cos(x), \quad (\cos(x))&#39; = -\sin(x)\]</span></p>
<p><span class="math display">\[(\tan(x))&#39;=\frac{1}{\cos^2 x}, \quad (\cot(x))&#39; = -\frac{1}{\sin^2(x)}\]</span></p>
<p><span class="math display">\[(\arcsin(x))&#39; = \frac{1}{\sqrt{1-x^2}}, \quad (\arccos(x))&#39; = -\frac{1}{\sqrt{1-x^2}}\]</span></p>
<p><span class="math display">\[(\arctan (x))&#39; = \frac{1}{x^2 + 1},\quad (arccot(x))&#39; = -\frac{1}{x^2 + 1}\]</span></p>
<p><span class="math display">\[(\sec(x))&#39; = \sec(x)\tan(x),\quad (\csc(x))&#39; = -\csc(x)\cot(x)\]</span></p>
<p><span class="math display">\[\frac{d}{dx}\int_{\psi (x)}^{\varphi (x)}f(t)dt=f\left[\varphi
  (x)\right]\varphi &#39;(x)-f[\psi (x)]\psi &#39;(x)\]</span></p>
<h4 id="不定积分-1">不定积分</h4>
<p><span class="math display">\[\int \frac{1}{\sqrt{a^2-x^2}} dx = \arcsin \frac{x}{a} + C\]</span></p>
<p><span class="math display">\[\int \frac{1}{a^2+x^2} dx = \frac{1}{a} \arctan \frac{x}{a} + C\]</span></p>
<p><span class="math display">\[\int \frac{1}{a^2-x^2} dx = \frac{1}{2a} \ln |\frac{a+x}{a-x}| + C\]</span></p>
<p><span class="math display">\[\int \sec x dx = \ln |\sec x + \tan x|+ C\]</span></p>
<p><span class="math display">\[\int \csc x dx = \ln |\csc x - \cot x|+ C\]</span></p>
<p><span class="math display">\[\int \frac{1}{\sqrt{x^2 \pm a^2}} dx = \ln |x +\sqrt{x^2 \pm a^2}| + C\]</span></p>
<h4 id="分部积分可循环形式">分部积分可循环形式</h4>
<p><span class="math inline">\(\sqrt{x^2 \pm a^2}, \quad \sqrt{a^2 - x^2}\)</span></p>
<h4 id="几个简单函数的-n-阶导数">几个简单函数的 n 阶导数</h4>
<p><span class="math display">\[(x^\alpha)^{(n)} = \alpha(\alpha-1)...(\alpha-n+1)x^{\alpha-n},\quad (x^n)^{(n)} = n!\]</span></p>
<p><span class="math display">\[\sin^{(n)}x = \sin(x+\frac{\pi}{2}n), \quad \cos^{(n)}{x} = \cos(x+\frac{\pi}{2}n)\]</span></p>
<p><span class="math display">\[(\frac{1}{x})^{(n)} = \frac{(-1)^n n!}{x^{n+1}}\]</span></p>
<p><span class="math display">\[[\alpha u(x) + \beta v(x)]^{(n)} = \alpha u^{(n)}(x) + \beta v^{(n)}(x)\]</span></p>
<p><span class="math display">\[(uv)^{(n)} = \sum_{k=0}^n u^{(n-k)} v^{(k)}\quad Leibniz 公式\]</span></p>
<h4 id="三角公式"><a href="http://baike.so.com/doc/5350859-5586315.html" target="_blank" rel="noopener">三角公式</a></h4>
<h5 id="三角与反三角">三角与反三角</h5>
<p><span class="math inline">\(\sec(x)\cos(x)=1,\quad \csc(x)\sin(x)=1,\quad \cot(x)\tan(x)=1,\quad\)</span></p>
<h5 id="两角和">两角和</h5>
<p><span class="math display">\[\cos(\alpha+\beta)=\cos \alpha \cdot \cos \beta-\sin \alpha \cdot \sin \beta\]</span></p>
<p><span class="math display">\[\sin(\alpha + \beta)=\sin \alpha  \cdot \cos \beta + \cos \alpha  \cdot \sin \beta\]</span></p>
<p><span class="math display">\[\tan(\alpha+\beta)=\frac{\tan\alpha+\tan\beta}{1-\tan\alpha \cdot \tan\beta}\]</span></p>
<h5 id="倍角公式">倍角公式</h5>
<p><span class="math display">\[\sin(2\alpha)=2\sin\alpha\cdot\cos\alpha\]</span></p>
<p><span class="math display">\[\cos(2\alpha)=(\cos\alpha)^2-(\sin\alpha)^2=2(\cos\alpha)^2-1=1-2(\sin\alpha)^2\]</span></p>
<p><span class="math display">\[\tan(2\alpha)=\frac{2\tan\alpha}{1-\tan^2\alpha}\]</span></p>
<h4 id="等价无穷小">等价无穷小</h4>
<p><span class="math display">\[\sqrt[n]{x+1} - 1 \sim \frac{x}{n}\]</span></p>
<p><span class="math display">\[1-\cos{x} \sim \frac{1}{2} x^2\]</span></p>
<p><span class="math display">\[\arcsin(x) \sim \sin(x) \sim \tan(x) \sim \arctan(x) \sim x\]</span></p>
<p><span class="math display">\[\tan(x) - \sin(x) \sim \frac{1}{2}x^3\]</span></p>
<p><span class="math display">\[ \ln(1+x) \sim x, \quad \log_a(1+x) \sim \frac{x}{\ln a}  \]</span></p>
<p><span class="math display">\[ e^x - 1 \sim x, \quad a^x - 1 \sim x\ln a \]</span></p>
<h4 id="不等式">不等式</h4>
<ul>
<li>基本不等式：<span class="math inline">\(a + b \ge 2\sqrt{a b}\)</span></li>
<li><span class="math inline">\(a + b \le 2(a^2 + b^2)\)</span></li>
</ul>
<h4 id="方向余弦">方向余弦</h4>
<p>对 <span class="math inline">\((\cos \alpha, \cos \beta)\)</span> 有</p>
<p><span class="math display">\[ \cos^2 \alpha + \cos^2 \beta = 1 \]</span></p>
<h4 id="数列和">数列和</h4>
<p>等比数列（几何数列） <span class="math inline">\(\{a_n\}\)</span> ，<span class="math inline">\(a_n = a_1q^{n-1}\)</span>， 和：</p>
<p><span class="math display">\[ S_n = \frac{a_1(1-q^n)}{1-q} = \frac{a_{n+1} - a_1}{q-1} \]</span></p>
<h4 id="导数运算">导数运算</h4>
<p>除法：</p>
<p><span class="math display">\[ (\frac{u}{v})&#39;(x) = \frac{u&#39;(x)v(x) - u(x)v&#39;(x)}{v^2(x)} \]</span></p>
<p>参数方程： <span class="math inline">\(y=y(t),\; x= x(t)\)</span></p>
<p><span class="math display">\[ \frac{dy}{dx} = \frac{dy}{dt}\frac{dt}{dx} = \cfrac{\frac{dy}{dt}}{\frac{dx}{dt}} \]</span></p>
<p><strong>复合函数求导的链式法则</strong>： <span class="math inline">\(z=z(u(x,y), v(x,y))\)</span></p>
<p><span class="math display">\[ \frac{\partial z}{\partial x} = \frac{\partial z}{\partial u}\frac{\partial u}{\partial x} + \frac{\partial z}{\partial v}\frac{\partial v}{\partial x} \]</span></p>
<p>隐函数：若 <span class="math inline">\(F(x,y)=0\)</span> 隐函数存在，则</p>
<p><span class="math display">\[ \frac{dy}{dx} = -\frac{F_x}{F_y} \]</span></p>
<p>隐函数推广到二元 <span class="math inline">\(F(x,y,z)=0\)</span> 有</p>
<p><span class="math display">\[ \frac{\partial z}{\partial x}=-\frac{F_x}{F_z} \]</span></p>
<h3 id="定义">定义</h3>
<h4 id="数列极限">数列极限</h4>
<p><span class="math inline">\(\forall \epsilon \gt 0\)</span>，<span class="math inline">\(\exists N \gt 0\)</span>，当 <span class="math inline">\(n \gt N\)</span> 时，有 <span class="math inline">\(|a_n - A| \lt \epsilon\)</span>，则 <span class="math inline">\(\lim_{n \rightarrow \infty}{a_n} = A\)</span></p>
<h4 id="函数极限有限值">函数极限（有限值）</h4>
<p><strong>要求</strong> 在 <span class="math inline">\(x_0\)</span> 的某去心邻域有定义，对 <span class="math inline">\(\forall \epsilon \gt 0\)</span>，都 <span class="math inline">\(\exists \delta &gt; 0\)</span>，使满足 <span class="math inline">\(0 \lt |x-x_0| \lt \delta\)</span> 的所有x，都有 <span class="math inline">\(|f(x) - A| \lt \delta\)</span>，则 <span class="math inline">\(\lim_{n \rightarrow x_0}{f(x)} = A\)</span></p>
<h4 id="二重函数极限">二重函数极限</h4>
<p><span class="math inline">\(f(x,y)\)</span> 的定义为 <span class="math inline">\(D\)</span>， <span class="math inline">\(P_0(x_0,y_0)\)</span> 为 <span class="math inline">\(D_f\)</span> 的聚点，对 <span class="math inline">\(\forall \epsilon \gt 0\)</span>，都 <span class="math inline">\(\exists \delta &gt; 0\)</span>， 使满足 <span class="math inline">\(0&lt;||PP_0||=\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\sigma\)</span> 的所有 <span class="math inline">\(P(x,y)\)</span>， 都有 <span class="math inline">\(|f(x,y)-A|&lt;\sigma\)</span>， 则</p>
<p><span class="math display">\[ \lim_{(x,y)\rightarrow (x_0,y_0)} f(x,y) = A\]</span></p>
<p>二重极限存在则 <span class="math inline">\(P(x,y)\)</span> 以 <strong>任意方式</strong> 接近 <span class="math inline">\(P_0(x_0,y_0)\)</span>， 其极限都存在。可以推广到更多元函数极限。</p>
<h4 id="连续">连续</h4>
<p>极限等于函数值，则该处连续。</p>
<h4 id="导数">导数</h4>
<p><span class="math display">\[ f&#39;(x_0) = \lim_{\Delta x \rightarrow 0} \frac {f(x_0 + \Delta x) - f(x_0)} {\Delta x} \]</span></p>
<h4 id="偏导数">偏导数</h4>
<p><span class="math display">\[ z_x= \frac{\partial z}{\partial x} = \lim_{\Delta x \rightarrow 0} \frac{f(x_0 + \Delta x, y_0) - f(x_0, y_0)}{\Delta x} \]</span></p>
<h4 id="二阶偏导">二阶偏导</h4>
<p><span class="math display">\[ \frac{\partial }{\partial x}(\frac{\partial z}{\partial x})=\frac{\partial^2 z }{\partial x^2} = f_{xx}(x,y),\quad \frac{\partial }{\partial y}(\frac{\partial z}{\partial x})=\frac{\partial^2 z }{\partial x \partial y} = f_{xy}(x,y) \]</span></p>
<h4 id="方向导数">方向导数</h4>
<p>若 <span class="math inline">\(z=f(x,y)\)</span> 可微，则存在沿 <a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E5%90%91%E9%A4%98%E5%BC%A6" target="_blank" rel="noopener">方向余弦</a> 为 <span class="math inline">\((\cos\alpha, \cos\beta)\)</span> 的方向 l 的方向导数</p>
<p><span class="math display">\[ \frac{\partial z}{\partial l} = \frac{\partial z}{\partial x} \cos \alpha + \frac{\partial z}{\partial l} \cos \beta \]</span></p>
<p>方向导数是函数沿 l 方向的变化率。偏导数是沿坐标轴的函数变化率。</p>
<h4 id="梯度">梯度</h4>
<p>梯度是一个向量：</p>
<p><span class="math display">\[ \mathbf{grad} f= \frac{\partial f}{\partial x} \mathbf{i} + \frac{\partial f}{\partial y} \mathbf{j} \]</span></p>
<h4 id="全微分">全微分</h4>
<p><strong>全增量</strong>：</p>
<p><span class="math display">\[ \Delta z = f(x+\Delta x, y+\Delta y) - f(x,y) \]</span></p>
<p>若偏导数 <span class="math inline">\(f_x(x_0, y_0）, f_y(x_0, y_0)\)</span> 均存在，且存在极限：</p>
<p><span class="math display">\[ \lim_{\Delta x,\Delta y \rightarrow 0} \frac{\Delta z - (f_x(x_0, y_0） \Delta x + f_y(x_0, y_0） \Delta y)}{\sqrt{\Delta x^2 + \Delta y^2}} = 0 \]</span></p>
<p>则全微分存在：</p>
<p><span class="math display">\[ dz = f_x(x_0, y_0) dx + f_y(x_0, y_0) dy \]</span></p>
<p><span class="math inline">\(f_x(x_0, y_0) dx + f_y(x_0, y_0) dy\)</span> 称为线性主部。可微时有： <span class="math inline">\(\Delta z = f_x(x_0, y_0) \Delta x + f_y(x_0, y_0) \Delta y + o(\sqrt{\Delta x^2+\Delta y^2})\)</span></p>
<h4 id="微分">微分</h4>
<p>若函数在某处可导，则有 <span class="math inline">\(\Delta y = f&#39;(x) \Delta x + o(\Delta x)\)</span>， 其中 <span class="math inline">\(dy = f&#39;(x)\Delta x = f&#39;(x) dx\)</span> 即该处微分。<span class="math inline">\(f&#39;(x)\Delta x\)</span> 称为线性主部。</p>
<h4 id="定积分">定积分</h4>
<p>关键字：分割，近似，求和，取极限</p>
<p>设函数 <span class="math inline">\(f(x)\)</span> 在有限区间 <span class="math inline">\([a, b]\)</span> 上有界，将 <span class="math inline">\([a, b]\)</span> 任意划分为 <span class="math inline">\(n\)</span> 个小区间，分点为：</p>
<p><span class="math display">\[a=x_0&lt;x_1&lt;x_2&lt;...&lt;x_n=b\]</span></p>
<p>在每个小区间 <span class="math inline">\([x_{i-1}, x_i]\; (i=1,2,...,n)\)</span> 上任取一点 <span class="math inline">\(\xi_i\; (x_{i-1} \le \xi_i \le x_i)\)</span>， 记</p>
<p><span class="math display">\[ \Delta x_i =x_i - x_{i-1}\; (i=1,2,...,n),\; \lambda=\max_{1\le i \le n}\{\Delta x_i\} \]</span></p>
<p>作和式</p>
<p><span class="math display">\[ \sum_{i=1}^n f(\xi_i)\Delta x_i \]</span></p>
<p>如果无论区间 <span class="math inline">\([a,b]\)</span> 怎样划分及点 <span class="math inline">\(\xi_i\)</span> 怎样选取，极限</p>
<p><span class="math display">\[ \lim_{\lambda \rightarrow 0} \sum_{i=1}^n f(\xi_i)\Delta x_i \]</span></p>
<p>的值都为同一常数，则称 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上可积，此极限值称为 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上的定积分，记为 <span class="math inline">\(\int_a^b f(x) dx\)</span>， 即</p>
<p><span class="math display">\[ \int_a^b f(x) dx = \lim_{\lambda \rightarrow 0} \sum_{i=1}^n f(\xi_i)\Delta x_i \]</span></p>
<p>其中 <span class="math inline">\(x\)</span> 称为 <strong>被积分变量</strong>， <span class="math inline">\(f(x)\)</span> 称为 <strong>被积函数</strong> ， <span class="math inline">\(f(x)dx\)</span> 称为 <strong>被积表达式</strong> ， <span class="math inline">\(a,b\)</span> 分别为 <strong>积分下限</strong>， <strong>积分上限</strong>， <span class="math inline">\(\int\)</span> 称为 <strong>积分符号</strong>， 表示和， <span class="math inline">\([a,b]\)</span> 为 <strong>积分区间</strong> 。</p>
<h4 id="不定积分-2">不定积分</h4>
<p>在定义域内，如果 <span class="math inline">\((F(x))&#39; = f(x)\)</span>，则 <span class="math display">\[\int f(x) dx = F(x) + C\]</span></p>
<h4 id="间断点">间断点</h4>
<p>不连续的点。第一类间断点，左右极限都存在。第二类间断点即不属于第一类间断点的间断点。</p>
<h4 id="基本初等函数">基本初等函数</h4>
<p>指六类函数：常量函数、幂函数、指数函数、对数函数、三角函数和反三角函数。以上函数通过有限次四则运算或有限次算命运算所得，且能用一个解析式表示的函数，称为 <strong>初等函数</strong>。</p>
<h4 id="驻点">驻点</h4>
<p>一阶导数为 0 的 <span class="math inline">\(x\)</span> 值。</p>
<h4 id="极值点">极值点</h4>
<p>对 <span class="math inline">\(\forall x \in\)</span> 去心邻域 <span class="math inline">\((x_0, \delta)\)</span>, 都有 <span class="math inline">\(f(x) \lt f(x_0)\)</span> （或 <span class="math inline">\(f(x) \gt f(x_0)\)</span>） 则称 <span class="math inline">\(x_0\)</span> 为极大（小）值点。</p>
<h4 id="函数凹凸性">函数凹凸性</h4>
<p><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 连续</p>
<p><span class="math display">\[f(\frac{x_1+x_2}{2}) &lt; \frac{f(x_1) + f(x_2)}{2}\]</span></p>
<p>则下凸，大于则上凸</p>
<h4 id="拐点">拐点</h4>
<p><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 附近连续，且两侧凸性相反，则 <strong><span class="math inline">\((x_0, f(x_0))\)</span></strong> 为拐点</p>
<h4 id="函数渐近线">函数渐近线</h4>
<ul>
<li>垂直渐近线 <span class="math inline">\(x=x_0\)</span></li>
</ul>
<p><span class="math display">\[\lim_{x \rightarrow x_0} f(x) = \infty\]</span></p>
<ul>
<li>水平渐近线 <span class="math inline">\(y=b\)</span></li>
</ul>
<p><span class="math display">\[\lim_{x \rightarrow \infty} f(x) = b\]</span></p>
<ul>
<li><p>斜渐近线 <span class="math inline">\(y=k x + b\)</span></p>
<ul>
<li><p><span class="math display">\[\lim_{x \rightarrow \infty} f(x) - (k x + b) = 0\]</span></p></li>
<li><p><span class="math display">\[k =\lim_{x\rightarrow \infty} \frac{f(x)}{x},\quad b = \lim_{x \rightarrow \infty} f(x) - k x\]</span></p></li>
</ul></li>
</ul>
<h4 id="函数曲率">函数曲率</h4>
<p><span class="math inline">\(\alpha \sim 角度,\quad s \sim 弧长,\quad K \sim 曲率\)</span></p>
<p><span class="math display">\[K = \lim_{\Delta s \rightarrow 0} |\frac{\Delta \alpha}{\Delta s}| = \frac{|y&#39;&#39;|}{(1+y&#39;^2)^{\frac{3}{2}}}\]</span></p>
<p>圆的曲率： <span class="math inline">\(K = 1 / R\)</span>。 <strong>曲率半径：</strong> <span class="math inline">\(1/K\)</span>, 曲率圆与函数曲线相切，以曲率半径为半径，曲率中心为曲率圆的圆心。</p>
<h4 id="反常积分">反常积分</h4>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B8%B8%E7%A9%8D%E5%88%86" target="_blank" rel="noopener">反常积分</a>又叫广义积分，是对普通定积分的推广，指含有无穷上限/下限，或者被积函数含有瑕点的积分，前者称为无穷限广义积分，后者称为瑕积分（又叫无界函数的反常积分）。</p>
<h4 id="无穷级数">无穷级数</h4>
<p>一个无穷序列的元素的和称为无穷级数。序列的通项称作级数的 <strong>通项</strong>， 若为常数，则称作常数项无穷级数，若为函数，称作函数项无穷级数。无穷级数是 <strong>函数逼近理论</strong> 的重要内容之一。</p>
<h3 id="定理">定理</h3>
<h4 id="微分偏导与连续">微分、偏导与连续</h4>
<p>对一阶，可微必可导，可导必连续，连续有极限。</p>
<p>对二阶，可微必偏导和连续，连续有极限。可微的充分条件：偏导函数存在且偏导函数连续。</p>
<h4 id="微分中值定理">微分中值定理</h4>
<h5 id="罗尔中值定理导数根存在定理">罗尔中值定理（导数根存在定理）</h5>
<p><span class="math inline">\(f(x)\)</span> 满足三个条件，一、在 <span class="math inline">\([a,b]\)</span> 连续，二、在 <span class="math inline">\((a,b)\)</span> 可导，三、 <span class="math inline">\(f(a)=f(b)\)</span> ，则 <span class="math inline">\(\exists \xi \in (a,b)\)</span>, 使得 <span class="math inline">\(f&#39;(\xi)=0\)</span>。几何意义：存在切线与端点连线平行。</p>
<h5 id="拉格朗日定理">拉格朗日定理</h5>
<p><span class="math inline">\(f(x)\)</span> 满足二个条件，一、在 <span class="math inline">\([a,b]\)</span> 连续，二、在 <span class="math inline">\((a,b)\)</span> 可导，则 <span class="math inline">\(\exists \xi \in (a,b)\)</span>, 使得</p>
<p><span class="math display">\[ f&#39;(\xi) = \frac{f(b) - f(a)}{b - a} \]</span></p>
<p>几何意义：存在切线与端点连线平行。</p>
<h5 id="柯西中值定理">柯西中值定理</h5>
<p><span class="math inline">\(f(x),\;g(x)\)</span> 满足二个条件，一、在 <span class="math inline">\([a,b]\)</span> 连续，二、在 <span class="math inline">\((a,b)\)</span> 可导，另外， <span class="math inline">\(\forall x \in (a,b)\)</span>， <span class="math inline">\(g&#39;(x) \ne 0\)</span>, 则 <span class="math inline">\(\exists\xi \in (a,b)\)</span>, 使得</p>
<p><span class="math display">\[ \frac{f(b) - f(a)}{g(b) - g(a)} = \frac{f&#39;(\xi)}{g&#39;(\xi)}\]</span></p>
<h4 id="泰勒公式">泰勒公式</h4>
<p><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 处 <span class="math inline">\(n\)</span> 阶可导，则</p>
<p><span class="math display">\[  f(x) = f(x_0) + f&#39;(x_0)(x-x_0) + \frac{f&#39;&#39;(x_0)}{2!}(x-x_0)^2 + ... + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)
\]</span></p>
<p><span class="math inline">\(R_n(x)\)</span> 称为余项</p>
<ul>
<li><strong>偑亚诺余项</strong> <span class="math inline">\(R_n(x) = o((x-x_0)^n)\)</span>,</li>
<li><strong>拉格朗日余项</strong> , <span class="math inline">\(\xi\)</span> 在 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(x\)</span> 之间</li>
</ul>
<p><span class="math display">\[R_n(x)=\frac{f^{n+1}(\xi)}{(n+1)!}(x-x_0)^{n+1}\]</span></p>
<h4 id="有界性定理">有界性定理</h4>
<p>函数连续则有界</p>
<h4 id="介值定理">介值定理</h4>
<p><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上连续，则存在一个介于 <span class="math inline">\(f(a) \sim f(b)\)</span> 的值</p>
<h5 id="根零点存在定理">根/零点存在定理</h5>
<p>如果 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 连续，且 <span class="math inline">\(f(a) \cdot f(b) &lt; 0\)</span>， 则 <span class="math inline">\(f(x) = 0\)</span> 存在根，如果 <span class="math inline">\(f(x)\)</span> 单调，则只存在一个根。</p>
<h4 id="可积的充要条件">可积的充要条件</h4>
<p>满足以下条件之一：</p>
<ul>
<li>f(x) 连续（则原函数可导）</li>
<li>单调有界</li>
<li>只有有限个第一类间断点且有界</li>
</ul>
<h4 id="定积分的性质">定积分的性质</h4>
<h5 id="定积分中值定理">（定）积分中值定理</h5>
<p><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上连续，则存在 <span class="math inline">\(\xi \in (a,b)\)</span></p>
<p><span class="math display">\[\int_a^b f(x) dx = f(\xi) (b-a)\]</span></p>
<h5 id="估值定理">估值定理</h5>
<p>设 M 与 m 分别为 f(x) 在 [a,b] 上的最大最小值，则</p>
<p><span class="math display">\[ m(b-a) \le \int_a^b f(x) dx  \le M(b-a) \]</span></p>
<h5 id="保号性">保号性</h5>
<p>如果在 [a,b] 上 <span class="math inline">\(f(x) \ge 0\)</span>， 则 <span class="math inline">\(\int_a^b f(x) dx \ge 0\)</span></p>
<p>推论1， <strong>保序性</strong>： 如果在 [a,b] 上 <span class="math inline">\(f(x) \ge g(x)\)</span>， 则 <span class="math inline">\(\int_a^b f(x) dx \ge \int_a^b g(x) dx\)</span></p>
<p>推论2： <span class="math inline">\(\int_a^b |f(x)| dx \ge |\int_a^b f(x) dx|\)</span></p>
<h5 id="区间可加性">区间可加性</h5>
<p>不论 a,b,c 三点相对位置，恒有 <span class="math inline">\(\int_a^b f(x) dx = \int_a^c f(x) dx + \int_c^b f(x) dx\)</span></p>
<h5 id="线性性">线性性</h5>
<p><span class="math inline">\(\int_a^b [k_1 f(x)+k_2 g(x)] dx = k_1 \int_a^b f(x) dx + k_2 \int_a^b g(x) dx\)</span></p>
<h4 id="奇偶函数的导函数">奇偶函数的导函数</h4>
<p>奇函数的导数为偶函数，偶函数的导数为奇函数</p>
<h4 id="极限的性质">极限的性质</h4>
<h5 id="局部有界性">（局部）有界性</h5>
<p>若 <span class="math inline">\(lim_{x \rightarrow x_0} f(x) = A\)</span>, 则 <span class="math inline">\(\exists\;M&gt;0,\;\delta &gt; 0\)</span>，对 <span class="math inline">\(\forall\; x \in U^\circ(x_0, \delta)\)</span>， 都有 <span class="math inline">\(|f(x)| \le M\)</span></p>
<h5 id="局部保号性">局部保号性</h5>
<p>若 <span class="math inline">\(lim_{x \rightarrow x_0} f(x) = A &gt; 0\)</span> （或 <span class="math inline">\(&lt;0\)</span> ）, 则 <span class="math inline">\(\exists \delta &gt;0\)</span>， 使得对 <span class="math inline">\(\forall x \in U^\circ(x_0,\delta)\)</span>， 都有 <span class="math inline">\(f(x) &gt; 0\;(&lt;0)\)</span></p>
<h4 id="极限存在准则">极限存在准则</h4>
<h5 id="夹逼准则">夹逼准则</h5>
<p>若在 <span class="math inline">\(x_0\)</span> 的某个空心邻域 <span class="math inline">\((x_0,\delta_0)\)</span> 内，有 <span class="math inline">\(g(x) \le f(x) \le h(x)\)</span> ，且 <span class="math inline">\(\lim_{x\rightarrow x_0} g(x) =lim_{x\rightarrow x_0} h(x)=A\)</span>， 则 <span class="math inline">\(lim_{x\rightarrow x_0} f(x)=A\)</span></p>
<h5 id="单调有界准则">单调有界准则</h5>
<p>单调有界数列必有极限，包括单调增加有上界，单调减少有下界两种情况</p>
<h4 id="隐函数存在定理一个方程">隐函数存在定理（一个方程）</h4>
<p>设方程 <span class="math inline">\(F(x,y)=0\)</span> 的左端函数 <span class="math inline">\(F(x,y)\)</span> 满足</p>
<ul>
<li>在点 <span class="math inline">\(P_0(x_0,y_0)\)</span> 的某一邻域内具有连续的偏导数 <span class="math inline">\(F_x,\; F_y\)</span></li>
<li><span class="math inline">\(F(x_0,y_0)=0\)</span></li>
<li><span class="math inline">\(F_y(x_0,y_0)\ne 0\)</span></li>
</ul>
<p>则在点 <span class="math inline">\(P_0(x_0, y_0)\)</span> 的某一邻域内，由方程 <span class="math inline">\(F(x,y)=0\)</span> 唯一确定单值连续且有连续导数的函数 <span class="math inline">\(y=f(x)\)</span>， 使得 <span class="math inline">\(F(x, f(x)) \equiv 0\)</span>， 且 <span class="math inline">\(y_0=f(x_0)\)</span> 并有：</p>
<p><span class="math display">\[ \frac{dy}{dx} = -\frac{F_x}{F_y} \]</span></p>
<p>可推广到多元隐函数</p>
<h4 id="偏导数与梯度">偏导数与梯度</h4>
<p>单位向量 <span class="math inline">\(\mathbf{l}(\cos \alpha, \cos \beta)\)</span> 的偏导数</p>
<p><span class="math display">\[ \frac{\partial f}{\partial l} = (\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}) \cdot (\cos \alpha, \cos \beta) = \mathbf{grad } f \cdot \mathbf{l} = ||\mathbf{grad} f|| \cdot \cos \theta \]</span></p>
<p>其中 <span class="math inline">\(\theta\)</span> 为梯度 <span class="math inline">\(\mathbf{grad} f\)</span> 与方向向量 <span class="math inline">\(\mathbf{l}\)</span> 的夹角。有以下结论：</p>
<ul>
<li>方向导数沿梯度方向取得最大值 <span class="math inline">\(||\mathbf{grad}f||\)</span></li>
<li>方向导数沿梯度反方向取得最小值 <span class="math inline">\(-||\mathbf{grad}f||\)</span></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/26/ML-MLT-4-kernelLogisticRegression/" itemprop="url">
                  机器学习技法第五课——Kernel Logistic Regression
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-26T23:32:41+08:00" content="2016-06-26">
              2016-06-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第五课——Kernel Logistic Regression——的课程笔记。</p>
<p>这节课主要讨论了 SVM 与 Logistic 回归的相似性，其目标是解决“SVM 从 0/1 分类到概率分类的转换”以及“Logistic 从低维空间到高维空间的转换”，提出了二个方法，一是，将 SVM 训练结果代入 Logistic 中训练，二是，使用 Logistic Regression 的 kernel 模型进行训练。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/205_handout.pdf" target="_blank" rel="noopener">课件</a></li>
<li><a href="https://en.wikipedia.org/wiki/Platt_scaling" target="_blank" rel="noopener">Platt scaling</a></li>
<li><a href="/2016/06/05/ML-MLT-2-kernelSVM/" title="Kernel SVM">Kernel SVM</a></li>
</ul>
<h3 id="svm-与-l2-正则化">SVM 与 L2 正则化</h3>
<p>推导 <a href="/2016/06/09/ML-MLT-3-softSVM/" title="Soft Margin SVM">Soft Margin SVM</a> 的原始公式： <span class="math display">\[  \min_{b,\mathbf{w},\xi} \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}\xi_n \\\\
s.t.\ y_n(\mathbf{w^Tz_n} + b) \ge 1 - \xi_n \\\\
s.t.\ \xi_n \ge 0
\]</span> <span class="math inline">\(\xi\)</span> 是松弛变量，也可视作 err，衡量越过 Margin 或分类超平面的程度，大致可以写成 <span class="math inline">\(err = \xi_n = \max{(1-y_n(w^T z_n + b),\; 0)}\)</span>, 原式大概可以写成： <span class="math display">\[  \min_{b,\mathbf{w}} \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}{\max{(1-y_n(w^T z_n + b),\; 0)}}
\]</span> <span class="math display">\[即\;\min{\frac{1}{2}\mathbf{w^Tw} + C\sum{err}}\]</span> 这个公式与<a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习基石</a>部分的带 L2 正则化的 PLA 算法比较相似。SVM 大致可以视作一个带 L2 正则化的分类器。（这个 error 常被称作 hinge loss）</p>
<h3 id="svm-与-logistic-相似">SVM 与 Logistic 相似</h3>
<p>令 <span class="math inline">\(s=w^T z + b\)</span> （超平面分类得分），引入<a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习基石</a>中的 0/1 错误、 Logistic 回归的错误与 SVM 错误比较：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">err type</th>
<th style="text-align: center;">function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0/1</td>
<td style="text-align: center;">[<span class="math inline">\(ys \le 0\)</span>]</td>
</tr>
<tr class="even">
<td style="text-align: center;">logistic</td>
<td style="text-align: center;"><span class="math inline">\(\ln(1+\exp(-ys))\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">SVM</td>
<td style="text-align: center;"><span class="math inline">\(\max(1-ys,\; 0)\)</span></td>
</tr>
</tbody>
</table>
<p>课程中作图更直观，在此就大致解释下 ：P。 <span class="math inline">\(y, s\)</span> 同号时，分类正确，0/1 分类中 “[]” 表示 bool 判断，如果 <span class="math inline">\(ys \le 0\)</span> 取1，反之取0，即分类正确 err 为 0，错误取 1 以记录错误。与之不同的是，Logistic 与 SVM 在分类错误时，不止记录了错误，而且在 <span class="math inline">\(ys\)</span> 越小时，err 取值越大。在分类正确时，后两者要么直接取 0，要么取一个 <span class="math inline">\(0 \sim 1\)</span> 的数。Logistic 与 SVM 都放大了分类错误数据的影响，而忽略分类正确数据的影响。</p>
<h3 id="platts-scaling">Platt’s scaling</h3>
<p><a href="https://en.wikipedia.org/wiki/Platt_scaling" target="_blank" rel="noopener">Platt scaling</a> 又称 Platt calibration，将分类模型对数据的预测评分作为输入，训练 Logistic 模型，将它转化成概率模型。运用这个方法将 SVM 与 Logistic 结合，使得 SVM 拥有概率特征，而 Logistic 可以用 SVM kernel 处理多维空间转换。大致过程为</p>
<ul>
<li>run SVM get <span class="math inline">\(\Phi_{svm}(z_n) = w^T z_n + b\)</span></li>
<li>run Logistic problem get A, B: <span class="math display">\[  \min_{A, B} {\frac{1}{N} \sum_{n=1}^{N}{ \ln{(1 + \exp(-y_n (A \Phi_{svm}(z_n) + B)))} }}
\]</span> 这里 A 是对 SVM 模型的一个放缩，对结果影响不大，而 B 有对原 SVM 有一定影响，应该尽量接近 0。在课程中，将这个模型称为 probabilistic SVM。</li>
</ul>
<h3 id="kernel-logistic-regression">Kernel Logistic Regression</h3>
<p>这一部分试图推导出 Logistic 的 kernel，以解决 Logistic 向高维空间映射的问题。提前声明一下，由于此模型不具有 SVM 的稀疏性，林老师在下节课会说明此方法相对 Platt’s scaling 较少使用。</p>
<p>首先，对于以下形式的“带 L2 正则化的线性模型” <span class="math display">\[  \min_{\mathbf{w}} \frac{\lambda}{N}\mathbf{w^Tw} + \frac{1}{N} \sum_{n=1}^{N}{err(y_n, w^T z_n)}
\]</span> 老师用奇妙的方法证明了其中的 <span class="math inline">\(\mathbf{w}\)</span> 可以被 <span class="math inline">\(\mathbf{z}\)</span> 线性表示 <span class="math display">\[\mathbf{w} = \sum_{n=1}^N \beta_n z_n\]</span> ，而且该模型能被转换成 kernel 形式。（至于如何证明的，因为十分奇妙在此略过 ：P）</p>
<p>当然，带 L2 正则化的 Logistic 回归模型符合以上条件。 <span class="math display">\[  \min_{w} { \frac{\lambda}{N}\mathbf{w^Tw}  +\frac{1}{N} \sum_{n=1}^{N}{ \ln{(1 + \exp(-y_n w^T z_n))} }}
\]</span></p>
<p>在 <a href="/2016/06/05/ML-MLT-2-kernelSVM/" title="Kernel SVM">Kernel SVM</a> 中，用 kernel 函数 <span class="math inline">\(K(\mathbf{x, x&#39;})\)</span> 替换 <span class="math inline">\(\mathbf{z^Tz&#39;}\)</span>，所以，接下来要把高维空间的 <span class="math inline">\(\mathbf{w, z}\)</span> 用 kernel 替换。 <span class="math display">\[ \mathbf{w^Tw} = \sum_{n=1}^{N}\sum_{n=1}^{M} \beta_n \beta_m K(\mathbf{x_n, x_m})\quad （向量内积分配律）\\\\
 \mathbf{w^Tz_n} = \sum_{m=1}^N {\beta_m K(\mathbf{x_m, x_n})}
\]</span></p>
<p>最后问题变成求解 <span class="math inline">\(\beta\)</span> <span class="math display">\[  \min_{w} { \frac{\lambda}{N} \sum_{n=1}^{N}\sum_{n=1}^{M} \beta_n \beta_m K(\mathbf{x_n, x_m})
 +\frac{1}{N} \sum_{n=1}^{N}{ \ln{(1 + \exp(-y_n \sum_{m=1}^N {\beta_m K(\mathbf{x_m, x_n})}))} }}
\]</span> 需要说明，<span class="math inline">\(\beta\)</span> 往往非 0，而对比 SVM 中的 <span class="math inline">\(\alpha\)</span>，则大多是 0（非支持向量），后者具有稀疏性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/09/ML-MLT-3-softSVM/" itemprop="url">
                  机器学习技法第四课——Soft-Margin SVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-09T18:31:14+08:00" content="2016-06-09">
              2016-06-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是本人学习林轩田老师的机器学习技法第四课——Soft-Margin Support Vector Machine——的课堂笔记。</p>
<p>前几节课的 SVM 不能容忍错误——包括不可分错误及可分分却在 margin 内的错误，这节课要解决这个问题，推导出 Soft Margin SVM。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/204_handout.pdf" target="_blank" rel="noopener">课件</a></li>
<li><a href="http://taop.marchtea.com/07.02.svm.html" target="_blank" rel="noopener">支持向量机</a></li>
<li><a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a></li>
</ul>
<h3 id="松弛变量">松弛变量</h3>
<p>引入松弛变量 <span class="math inline">\(\xi\)</span>，放宽条件，同时避免过度放宽，在最小化公式中也加入 <span class="math inline">\(\xi\)</span>： <span class="math display">\[  \min_{b,\mathbf{w},\xi} \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}\xi_n \\\\
s.t.\ y_n(\mathbf{w^Tz_n} + b) \ge 1 - \xi_n \\\\
s.t.\ \xi_n \ge 0
\]</span> 此处 <span class="math inline">\(C\)</span> 是一个常量，作为平衡“large margin”与“margin violation”的参数。 <span class="math inline">\(\xi\)</span> 在限制条件中确实减小了下限，放宽了条件，但至于这背后为何能使 SVM 容忍错误，这可能要从头开始推导了。很明显，这已经可以用二次规划求解。</p>
<h3 id="对偶问题">对偶问题</h3>
<p>转换成对偶问题，用前面课程 <a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a> 中同样的方法。</p>
<h4 id="拉格朗日乘数">拉格朗日乘数</h4>
<p><span class="math display">\[  L(b,\mathbf{w},\alpha,\beta) = \frac{1}{2}\mathbf{w^Tw} + C \sum_{n=1}^{N}\xi_n + \sum_{n=1}^N \alpha_n(1-\xi_n-y_n(\mathbf{w^T z_n} + b)) + \sum_{n=1}^N \beta_n (-\xi_n)
\]</span> 求解： <span class="math display">\[   \max_{\alpha_n \ge 0,\ \beta_n \ge 0} (min_{b,\mathbf{w},\xi} L(b,\mathbf{w},\alpha,\beta))
\]</span></p>
<h4 id="求导化简成关于-alpha-的函数">求导化简成关于 <span class="math inline">\(\alpha\)</span> 的函数</h4>
<p><span class="math display">\[    \frac{\partial L}{\partial \xi_n} = C - \alpha_n - \beta_n\\\\
let\ \ \beta_n= C -\alpha_n
\]</span> 因为条件中有 <span class="math inline">\(\alpha_n \ge 0\)</span>，故 <span class="math inline">\(C \ge \alpha_n \ge 0\)</span>。如此原式变换为： <span class="math display">\[    \max_{$0 \le \alpha_n \le C,\ \beta_n=C-\alpha_n} (\min_{b,\mathbf{w},\xi} \frac{1}{2} \mathbf{w^T w} + \sum_{n=1}^{N}\alpha_n(1 - y_n(\mathbf{w^T \mathbf{z_n}} + b)))
\]</span> 这一步增加了限制条件，但消去了 <span class="math inline">\(\beta, \xi, C\)</span>。接下来与 <a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a> 的过程相同，令 <span class="math inline">\(\frac{\partial L}{\partial b} = 0, \frac{\partial L}{\partial w_i} = 0\)</span> 化简得： <span class="math display">\[
\min_{\alpha_n} (\frac{1}{2}\sum_{m=1}^{N} \sum_{n=1}^{N} y_m  y_n \mathbf{z_m^T} \mathbf{z_n} \alpha_m \alpha_n - \sum_{n=1}^{N}\alpha_n) \\\\
s.t.\ \ \sum_{n=1}^N y_n \alpha_n = 0,\ \ all\ 0 \le \alpha_n \le C
\]</span> 看上去与之前的差别只有对 <span class="math inline">\(\alpha\)</span> 加上上限 C。</p>
<h4 id="求解-b">求解 <span class="math inline">\(b\)</span></h4>
<p>部分 KKT 条件： <span class="math display">\[  \alpha_n(1-\xi_n-y_n(\mathbf{w^T z_n} + b)) = 0 \\\\
(C - \alpha_n) \xi_n = 0  \]</span> 因为除 <span class="math inline">\(\xi,\ b\)</span> 其他都是已知量，所以只要求解方程组就能得到解。而多数情况下，当 <span class="math inline">\(0 \lt \alpha_n \lt C\)</span> 时，被称为 free Support Vector，可推导出 <span class="math display">\[  b = y_s - \mathbf{w^T z_s}
\]</span> 之后的求解过程与前面课程没什么不同。</p>
<h3 id="alpha_n-与向量角色"><span class="math inline">\(\alpha_n\)</span> 与向量角色</h3>
<p>根据 KKT 条件，当 <span class="math inline">\(\alpha_n = 0\)</span> 时，松弛变量 <span class="math inline">\(\xi_n=0\)</span>，没有错误，被称为非支持向量，<strong><em>non SV</em></strong>，处于 margin 外界；</p>
<p>当 <span class="math inline">\(0 \lt \alpha \lt C\)</span> 时，<span class="math inline">\(\xi_n=0\)</span>，没有错误，而且可以求解 <span class="math inline">\(b\)</span>，被称为 <strong><em>free SV</em></strong>，位于 margin 上；</p>
<p>当 <span class="math inline">\(\alpha = C\)</span> 时， <span class="math inline">\(\xi_n \ne 0\)</span>，有错误，同样可以帮助求解，被称为 <strong><em>bounded SV</em></strong>，位于 margin 内部或越过了超平面。</p>
<h3 id="looc-帮助模型选择">LOOC 帮助模型选择</h3>
<p>模型选择时，可以用 Cross Validation 做参考，其中特别的有 Leave-One-Out CV，即只留一个数据点做验证。</p>
<p>将 Leave-One-Out CV 与全数据集（不留验证数据）的训练做比较。如果验证数据是一个 non-SV，那么，2 者的错误是相同的，而如果验证数据是一个 SV，那么有可能分类错误。所以有 <span class="math display">\[  E_{loocv} \le \frac{num(SV)}{N} \]</span> 这里存在疑问的是，如果验证数据是一个很关键的 SV，可能极大地影响超平面的训练结果，这个 bound 是否成立。</p>
<p>这个上限可以用做安全检查，在训练模型之后便能得到 <span class="math inline">\(E_{loocv}\)</span> 的上限，可以排除一些结果太差的模型，节省时间，但它的作用有限，不能断定一个模型的好坏。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/07/Algo-asymptoticAnalysis/" itemprop="url">
                  算法时间复杂度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-07T21:07:37+08:00" content="2016-06-07">
              2016-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index">
                    <span itemprop="name">Algo</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Coursera 上 <a href="https://class.coursera.org/algo-009/lecture" target="_blank" rel="noopener">Algorithms: Design and Analysis, Part 1 by Tim Roughgarden</a> 的学习笔记。第二课，有关时间复杂度。</p>
<h4 id="the-gist">The Gist</h4>
<p>时间复杂度计算概略地讲，就是“suppress constant factors and lower-order terms”</p>
<h4 id="big-oh-notation">Big-Oh Notation</h4>
<p>Formal Definition: <span class="math inline">\(T(n) = O(f(n))\)</span><br>
if and only if exist constants <span class="math inline">\(c, n_0\)</span> such that <span class="math inline">\(T(n) \le cf(n)\)</span><br>
for all <span class="math inline">\(n \gt n_0\)</span></p>
<p>即 <span class="math inline">\(n \rightarrow +\infty\)</span> 时，<span class="math inline">\(cf(n)\)</span> 为 <span class="math inline">\(T(n)\)</span> 上限</p>
<h4 id="omega-notation">Omega Notation</h4>
<p>Formal Definition: <span class="math inline">\(T(n) = \Omega(f(n))\)</span><br>
if and only if exist constants <span class="math inline">\(c, n_0\)</span> such that <span class="math inline">\(T(n) \ge cf(n)\)</span><br>
for all <span class="math inline">\(n \gt n_0\)</span></p>
<p>即 <span class="math inline">\(n \rightarrow +\infty\)</span> 时，<span class="math inline">\(cf(n)\)</span> 为 <span class="math inline">\(T(n)\)</span> 下限</p>
<h4 id="theta-notation">Theta Notation</h4>
<p>Formal Definition: <span class="math inline">\(T(n) = \Theta(f(n))\)</span><br>
if and only if <span class="math inline">\(T(n)=O(f(n))\)</span> and <span class="math inline">\(\Omega(n)=O(f(n))\)</span></p>
<p>即 <span class="math inline">\(n \rightarrow +\infty\)</span> 时，<span class="math inline">\(cf(n)\)</span> 既能作 <span class="math inline">\(T(n)\)</span> 下限也能作上限，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/05/ML-MLT-2-kernelSVM/" itemprop="url">
                  机器学习技法第三课——Kernel SVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-05T21:45:49+08:00" content="2016-06-05">
              2016-06-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第三课——Kernel Support Vector Machine——的课堂笔记。</p>
<p>给定上节课的公式： <span class="math display">\[
\min_{\alpha_n} (\frac{1}{2}\sum_{m=1}^{N} \sum_{n=1}^{N} y_m y_n \mathbf{z_m^T}  \mathbf{z_n} \alpha_m \alpha_n - \sum_{n=1}^{N}\alpha_n) \\\\
s.t.\ all\ \alpha_n \ge 0,\ \sum_{n=1}^N \alpha_n y_n = 0
\]</span> 这里 <span class="math inline">\(\mathbf{z}\)</span> 是由 <span class="math inline">\(\mathbf{x}\)</span> 变换得到。在 <span class="math inline">\(\mathbf{x}\)</span> 向量所处的空间里，如果所有超平面都不能对数据进行分类，可以将 <span class="math inline">\(\mathbf{x}\)</span> 映射到高维空间，也就是 <span class="math inline">\(\mathbf{x}\)</span> 变换成 <span class="math inline">\(\mathbf{z}\)</span>。这次课的目标包括：了解这种变换带来的求解问题，引入核函数、多项式核函数、高斯核函数，及了解如何选择核 SVM 或线性 SVM。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/05/31/ML-MLT-1-dualSVM/" title="Dual Support Vector Machine">Dual Support Vector Machine</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/203_handout.pdf" target="_blank" rel="noopener">课件</a></li>
</ul>
<h3 id="求解复杂度">求解复杂度</h3>
<p>考虑将 <span class="math inline">\(\mathbf{x}\)</span> 从一次变换到二次： <span class="math display">\[\mathbf{x} = (x_1, x_2, ..., x_d) \ \ \rightarrow \\\\
\mathbf{z} = (1, x_1, x_2, ..., x_d, x_1 x_1, x_1 x_2, ..., x_1 x_d, x_2 x_1, x_2 x_2, ..., x_2 x_d, ..., x_d x_d)\]</span></p>
<p>向量长度增加了 <span class="math inline">\(d^2 + 1\)</span>，由于在求解公式中需要计算任意2个 <span class="math inline">\(\mathbf{x}\)</span> 的内积（<span class="math inline">\(\mathbf{z_m^T z_n}\)</span>），计算复杂度从 <span class="math inline">\(o(d^2)\)</span> 增加到 <span class="math inline">\(o(d^4)\)</span>，陡增了不少困难。而这仅是变换到二次的情况。</p>
<h3 id="核函数">核函数</h3>
<p>就 <strong><em>求解复杂度</em></strong> 一节所举一次变二次，有以下推导： <span class="math display">\[\mathbf{z^T z&#39;} = 1 + \sum_{i=1}^d x_i x&#39;_i + \sum_{i=1}^d \sum_{j=1}^d x_i x_j x&#39;_i x&#39;_j \\\\
=1 + \sum_{i=1}^d x_i x&#39;_i + (\sum_{i=1}^d x_i x&#39;_i) (\sum_{j=1}^d x_j x&#39;_j) \\\\
=1 + \mathbf{x^T x&#39;} + (\mathbf{x^T x&#39;})(\mathbf{x^T x&#39;})\]</span> 可见任意2个 <span class="math inline">\(\mathbf{w}\)</span> 的内积（<span class="math inline">\(\mathbf{z^T z&#39;}\)</span>）可以用 <span class="math inline">\(\mathbf{x}\)</span> 的内积表示。这可以推广到更高次变换。</p>
<p>这种处理有何好处？复杂度大幅降低，从原来的 <span class="math inline">\(o(d^4)\)</span> 回降到 <span class="math inline">\(o(d^2)\)</span>。</p>
<h4 id="核函数-1">核函数</h4>
<p>简单来说，核函数（核）应该是： <span class="math display">\[\mathbf{z^T z&#39;} = K(\mathbf{x}, \mathbf{x&#39;})\]</span> 在一次变二次例子中 <span class="math inline">\(K(\mathbf{x}, \mathbf{x&#39;}) =1 + \mathbf{x^T x&#39;} + (\mathbf{x^T x&#39;})(\mathbf{x^T x&#39;})\)</span>。</p>
<p>原求解公式变换为： <span class="math display">\[
\min_{\alpha_n} (\frac{1}{2}\sum_{m=1}^{N} \sum_{n=1}^{N} y_m y_n K(\mathbf{x}_m, \mathbf{x}_n) \alpha_m \alpha_n - \sum_{n=1}^{N}\alpha_n) \\\\
s.t.\ all\ \alpha_n \ge 0,\ \sum_{n=1}^N \alpha_n y_n = 0
\]</span> 设 <span class="math inline">\((\mathbf{x}_s, y_s)\)</span> 为支持向量（<span class="math inline">\(\alpha_s = 0\)</span>）解出 <span class="math inline">\(b\)</span>: <span class="math display">\[
b = y_s - \mathbf{w^T \mathbf{z_s}} \\\\
= y_s - (\sum_{n=1}^{N} \alpha_n y_n \mathbf{z_n})^\mathbf{T} \mathbf{z}_s \\\\
= y_s - \sum_{n=1}^{N} \alpha_n y_n K(\mathbf{x}_n, \mathbf{x}_s)
\]</span> 求解 <span class="math inline">\(\mathbf{w}\)</span> 似乎有点复杂，但不影响最终分类。分类公式变换为 <span class="math display">\[g_{svm}(\mathbf{x}) = sign(\mathbf{w^T z} + b)
=sign(\sum_{n=1}^{N} \alpha_n y_n K(\mathbf{x}_n, \mathbf{x}) + b)\]</span></p>
<h4 id="多项式核函数">多项式核函数</h4>
<p><span class="math display">\[K(\mathbf{x}, \mathbf{x&#39;}) = (\zeta + \gamma \mathbf{x^T x&#39;})^q,\ with\ \zeta \ge 0,\ \gamma \gt 0\]</span> 例如，当 <span class="math inline">\(q = 2\)</span> 时， <span class="math display">\[\mathbf{z^T z&#39;} = K(\mathbf{x}, \mathbf{x&#39;}) =1 + 2\zeta\gamma\mathbf{x^T x&#39;} + \gamma^2(\mathbf{x^T x&#39;})^2 \\\\
\Rightarrow \mathbf{z} = (1, \sqrt{2\zeta\gamma}x_1,  \sqrt{2\zeta\gamma}x_2, ...,  \sqrt{2\zeta\gamma}x_n, \gamma x_1 x_1, \gamma x_1 x_2, ..., \gamma x_n x_n)\]</span> 感觉这个核不能满足所有从 <span class="math inline">\(\mathbf{x}\)</span> 到 <span class="math inline">\(\mathbf{z}\)</span> 的多项式变换，比如 <span class="math inline">\(\mathbf{z}\)</span> 中至少所有一次项系数都相等（在上例中为 <span class="math inline">\(\sqrt{2\zeta\gamma}\)</span>）。</p>
<h4 id="高斯核函数">高斯核函数</h4>
<p><span class="math display">\[K(\mathbf{x}, \mathbf{x&#39;}) = exp(-\gamma |\mathbf{x - x&#39;}|^2),\ with\ \gamma \gt 0\]</span> 高斯（Gaussian）核函数可以将 <span class="math inline">\(\mathbf{x}\)</span> 扩展到无限维。</p>
<p>课上只给了 <span class="math inline">\(\gamma = 1,\ \mathbf{x} = (x)\)</span>（<span class="math inline">\(\mathbf{x}\)</span> 只有一个维度）时的推导： <span class="math display">\[K(\mathbf{x}, \mathbf{x&#39;}) = exp(-(\mathbf{x - x&#39;})^2) \\\\
=exp(-x^2)exp(-x&#39;^2)exp(2xx&#39;)\\\\
=exp(-(x)^2)exp(-(x&#39;)^2) \sum_{i=0}^\infty \frac{(2xx&#39;)^i}{i!},\ \ taylor\ expansion \\\\
=\sum_{i=0}^\infty(exp(-x^2)exp(-x&#39;^2) \sqrt{\frac{2^i}{i!}} \sqrt{\frac{2^i}{i!}} x^i x&#39;^i) \\\\
=\mathbf{z^T z&#39;} \\\\
with\ \mathbf{z}=exp(-x^2)(1, \sqrt{\frac{2}{1!}} x, \sqrt{\frac{2^2}{2!}}x^2, ...)
\]</span></p>
<p>如果 <span class="math inline">\(\gamma\)</span> 取值过大（方差过大），高斯核会过拟合。</p>
<h3 id="核函数并非万能">核函数并非万能</h3>
<p>线性 SVM 指原始的，<span class="math inline">\(\mathbf{x}\)</span> 未经变换的 SVM，求解相对多项式核 SVM 简单（系数矩阵为对角矩阵），而且，参数选择较少。而高斯核的模型难以解释，且容易过拟合。</p>
<p>对于高次的多项式 kernel，可以考虑用原始的方法，将 <span class="math inline">\(\mathbf{x}\)</span> 转化成 <span class="math inline">\(\mathbf{z}\)</span> 之后代入线性 SVM 求解，如果维度不高，求解速度会更快。</p>
<h3 id="其他核函数">其他核函数</h3>
<p>课上指出，能成为核函数的充要条件是，核函数导出的矩阵 <span class="math inline">\(\mathbf{K}\)</span>，<span class="math inline">\(k_{i,j}=K(\mathbf{x_i, x_j})\)</span>，是对称且半正定的。这2个条件被称为 Mercer’s condition。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/Python-cheatSheet/" itemprop="url">
                  Python 杂记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-03T10:58:50+08:00" content="2016-06-03">
              2016-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="参考">参考</h3>
<ul>
<li><a href="http://blog.csdn.net/sasoritattoo/article/details/12451359" target="_blank" rel="noopener">python代码 `if not x:` 和`if x is not None:`和`if not x is None:`使用</a></li>
<li><a href="http://www.2cto.com/kf/201405/300359.html" target="_blank" rel="noopener">python变量和作用域</a></li>
<li><a href="http://www.cnblogs.com/ifantastic/archive/2013/04/15/3021845.html" target="_blank" rel="noopener">Python 序列的切片操作与技巧</a></li>
</ul>
<h3 id="函数和常用语法">函数和常用语法</h3>
<h4 id="raw_input-与-input">raw_input 与 input</h4>
<p><code>raw_input</code> 只在 2 中存在，返回字符串，在 2 中，<code>input</code> 返回输入表达式的值；<br>
3 中 input 返回字符串。</p>
<h4 id="type">type</h4>
<p>查看变量类型</p>
<h4 id="交换两变量值">交换两变量值</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<h4 id="whilefor-else-语句">while/for else 语句</h4>
<p>跟 if else 相同，在 while/for 条件为假时执行 else。所以，在未进入循环或循环正常完成后，else 部分会执行，而循环被 break 或出现异常，则不会执行 else。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">"Sat"</span>,<span class="string">"Sun"</span>,<span class="string">"Mon"</span>]:</span><br><span class="line">  <span class="keyword">if</span> value == <span class="string">"Sun"</span>:</span><br><span class="line">    print(<span class="string">"Bingo!"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">"No Sunday."</span>)</span><br></pre></td></tr></table></figure>
<h4 id="yield-关键字">yield 关键字</h4>
<p>在函数中使用 yield 关键字让函数返回一个 <strong>生成器</strong>。 该生成器调用方式十分奇特，类似于断点调试，在调用其 <code>next()</code> 方法时运行到 yield 关键字处并返回参数，可多次调用直到函数结束（抛出 StopIteration 异常）。可以在函数中使用多个 yield，就像设置多个断点。隐含的一个特性是，每次只能取到下一个值，而不能回退取到上一个值。通常用 <code>for/while</code> 循环使用生成器，以代替循环调用 <code>next()</code>，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(stop)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"step in"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(stop):</span><br><span class="line">        <span class="keyword">yield</span> i  <span class="comment"># 当代码运行到此处返回 i</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"yield %g"</span> % i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">g = gen(<span class="number">3</span>)  <span class="comment"># 函数返回一个生成器</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"called gen"</span>  <span class="comment"># 在调用 g.next() 方法前，gen 内代码不会执行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<h4 id="sign-函数">sign 函数</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = <span class="keyword">lambda</span> a: <span class="number">1</span> <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="print-不换行">print 不换行</h4>
<p>python2 中 print 不换行，python3 中使用参数 <code>end=''</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World"</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="dict-键列表">dict 键列表</h4>
<p>使用 <code>list(dict)</code> 获取 <code>dict</code> 的键列表</p>
<h3 id="惯用处理">惯用处理</h3>
<h4 id="从文件路径获取文件名与扩展名">从文件路径获取文件名与扩展名</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">filepath = <span class="string">'/tmp/log.txt'</span></span><br><span class="line">filename = os.path.basename(filepath) <span class="comment"># 文件名</span></span><br><span class="line">print(os.path.splitext(filename)) <span class="comment"># 分离扩展名</span></span><br></pre></td></tr></table></figure>
<h4 id="时间">时间</h4>
<p>datetime 与 字符串相互转换 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">id_s = <span class="string">"337259199211056344"</span>[<span class="number">6</span>:<span class="number">14</span>] <span class="comment"># 身份证号</span></span><br><span class="line">d = datetime.strptime(id_s, <span class="string">'%Y%m%d'</span>)</span><br><span class="line">print((datetime.now() - d).days)  <span class="comment"># 距今多少天，datetime相减得delta对象</span></span><br><span class="line">print(d.strftime(<span class="string">'%Y-%m-%d'</span>)) <span class="comment"># datetime 格式化输出字符串</span></span><br></pre></td></tr></table></figure></p>
<h4 id="判断对象为数字">判断对象为数字</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">print(isinstance(x, numbers.Number))</span><br></pre></td></tr></table></figure>
<h4 id="读-excel-表">读 excel 表</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(excel_name, sheet_name)</span>:</span></span><br><span class="line">    bk = xlrd.open_workbook(excel_name)</span><br><span class="line">    sh = bk.sheet_by_name(sheet_name)</span><br><span class="line"></span><br><span class="line">    nrows = sh.nrows <span class="comment">#获取行数</span></span><br><span class="line">    ncols = sh.ncols <span class="comment">#获取列数</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"excel %s, sheet %s, nrows %d, ncols %d"</span> % (excel_name, sheet_name, nrows,ncols))</span><br><span class="line"></span><br><span class="line">    row_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, nrows):    <span class="comment">#获取各行数据</span></span><br><span class="line">        row_data = sh.row_values(i)</span><br><span class="line">        row_list.append(row_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> row_list</span><br></pre></td></tr></table></figure>
<h4 id="生成随机数">生成随机数</h4>
<h5 id="random">random</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.random() <span class="comment"># 0 到 1 小数</span></span><br><span class="line">random.randint(m,n) <span class="comment"># m 到 n 整数</span></span><br><span class="line">random.sample(list, n) <span class="comment"># 从 list 不放回抽样 n 个，返回列表</span></span><br></pre></td></tr></table></figure>
<h5 id="正态随机">正态随机</h5>
<p>生成正态随机数列可用<code>numpy.random.normal(mu, sigma, sample_num)</code></p>
<h4 id="正则">正则</h4>
<p>匹配例子 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"截止日期：2016-7-11 2:44:29。余额：137533。逾期金额：28747。"</span></span><br><span class="line">print(re.findall(<span class="string">r"余额：(.+?)。"</span>, str))</span><br></pre></td></tr></table></figure></p>
<h3 id="list-操作">list 操作</h3>
<h4 id="range">range()</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(stat=0,stop,step=1)</span></span><br><span class="line">range(<span class="number">10</span>) <span class="comment"># 返回 0 到 9 列表</span></span><br><span class="line">range(<span class="number">1</span>,<span class="number">10</span>) <span class="comment"># 返回 1 到 9 列表</span></span><br><span class="line">range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># 返回以 2 为步长 1 到 9 列表</span></span><br><span class="line">range(<span class="number">0</span>,<span class="number">-10</span>,<span class="number">-1</span>) <span class="comment"># 返回 0 到 -9 列表</span></span><br></pre></td></tr></table></figure>
<h4 id="列表推导式">列表推导式</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="comment"># 创建一个新 list</span></span><br></pre></td></tr></table></figure>
<h4 id="切片">切片</h4>
<p>list 切片作为右值，会复制数据并返回引用。而对切片的修改会直接作用于原 list 上。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list[start:stop:step], 用法类似 range，如果意义明确，可省略参数</span></span><br><span class="line"><span class="comment"># 索引可为负，可以超出范围</span></span><br><span class="line">la = lb <span class="comment"># 只能复制引用</span></span><br><span class="line">la = lb[:] <span class="comment"># 复制数据，返回引用给 la</span></span><br><span class="line">lb[::<span class="number">-1</span>] <span class="comment"># lb 逆序列表 copy</span></span><br><span class="line">lb[<span class="number">-2</span>:<span class="number">-1</span>] = [<span class="number">2</span>, <span class="number">4</span>] <span class="comment"># 将 lb 最后两个数赋为 2, 4</span></span><br><span class="line"><span class="keyword">del</span> lb[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 删除 lb 第 0、1 号元素</span></span><br></pre></td></tr></table></figure></p>
<h4 id="增加元素">增加元素</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.append(x) <span class="comment"># 追加到末尾</span></span><br><span class="line">list.insert(i, x) <span class="comment"># 插入到 i 处</span></span><br><span class="line">la = lb + lc <span class="comment"># 创建一个新 list，顺序加入 lb、lc 中元素</span></span><br><span class="line">la.extend(lb) <span class="comment"># 在 la 中依次添加 lb 中元素</span></span><br></pre></td></tr></table></figure>
<h4 id="判断元素存在">判断元素存在</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">in</span> list <span class="comment"># 返回 bool 类型，是否存在 x</span></span><br><span class="line">list.count(x) <span class="comment"># 返回 x 出现次数</span></span><br></pre></td></tr></table></figure>
<h4 id="按索引查元素">按索引查元素</h4>
<p>索引可为负，范围： [-len, len-1]</p>
<h4 id="按元素查索引">按元素查索引</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.index(x) <span class="comment"># 第一次出现 x 位置，如果 x 不存在会报错</span></span><br></pre></td></tr></table></figure>
<h4 id="删除元素">删除元素</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> list[index] <span class="comment"># 删除 index 处元素</span></span><br><span class="line">list.remove(x) <span class="comment"># 删除 x 元素，如果不存在会报错</span></span><br><span class="line">list.pop(index=<span class="number">-1</span>) <span class="comment"># 返回并删除 index 处元素</span></span><br><span class="line"><span class="comment"># 直接用切片复制保留元素到新列表中，也是一种方法</span></span><br></pre></td></tr></table></figure>
<h4 id="反转">反转</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.reverse()</span><br></pre></td></tr></table></figure>
<h4 id="zip-合并">zip 合并</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip(la,lb,lc) <span class="comment"># “同索引元素”组成元组，构成列表，长度为输入最短列表的长度</span></span><br><span class="line">[a + b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(la,lb)]</span><br></pre></td></tr></table></figure>
<h3 id="模块">模块</h3>
<p>一个模块是一个源文件，文件名即模块名。模块由 <code>import</code> 语句加载后，便可以访问其中定义的对象。</p>
<h4 id="import-与-from-import">import 与 from import</h4>
<p>当 python 解释器 <code>import</code> 一个模块时，会执行其中的代码。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module <span class="comment"># 加载 module，使用其中对象时应该用 module.obj</span></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> obj <span class="comment"># 加载 module，只能使用 obj 对象，不用加 module 前缀</span></span><br></pre></td></tr></table></figure></p>
<h4 id="name__-属性"><code>__name__</code> 属性</h4>
<p>当 python 解释器加载一个模块时，会设置每个模块的属性 <code>__name__</code>。 只有当前运行模块的该属性被设置为 <code>__main__</code>，所以可用以下语句判断当前模块是否是程序入口 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h4 id="模块搜索路径">模块搜索路径</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sys.path 列表存储了模块搜索路径</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path <span class="comment"># 可修改该列表以修改模块搜索路径</span></span><br></pre></td></tr></table></figure>
<p>搜索路径初始包括：</p>
<ul>
<li>运行脚本目录</li>
<li>环境变量 PYTHONPATH 中存储的值</li>
<li>Python 模块的安装目录</li>
</ul>
<h4 id="dir">dir()</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir() <span class="comment"># 返回当前模块定义的对象名列表</span></span><br><span class="line">dir(module) <span class="comment"># 返回 module 定义的对象名列表</span></span><br></pre></td></tr></table></figure>
<h4 id="模块安装">模块安装</h4>
<p>三种方式：</p>
<p>进入下载安装包目录，运行 setup.py 程序： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码安装</span></span><br><span class="line">cd download_dir</span><br><span class="line">python setup.py install <span class="comment"># 运行 setup.py 安装程序</span></span><br><span class="line"><span class="comment"># 用 pip 安装，自动安装依赖包</span></span><br><span class="line">pip install PackageName</span><br><span class="line"><span class="comment"># 用 easy_install 安装，不推荐使用</span></span><br><span class="line">easy_install PackageName</span><br></pre></td></tr></table></figure></p>
<h4 id="win下-anaconda-安装依赖包">win下 Anaconda 安装依赖包</h4>
<p>进入Anaconda安装目录 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Scripts</span><br><span class="line">pip install PackageName -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"># -i 后接国内镜像地址url，提升速度</span><br></pre></td></tr></table></figure></p>
<h3 id="包">包</h3>
<p>是一个包含 __init__.py 的文件夹，导入模块时需要加上包前缀，类似 Java。</p>
<h3 id="作用域">作用域</h3>
<h4 id="三大作用域">三大作用域</h4>
<p>只有模块（module），类（class）以及函数（<code>def</code>、<code>lambda</code>）才会引入新的作用域，其它的代码块（如if、try、for等，甚至列表推导式也是）不会引入新的作用域</p>
<h4 id="子级作用域与上级">子级作用域与上级</h4>
<p>在子级作用域可访问上级作用域变量。让上级变量指向另一个对象不能使用语句 <code>same_name = obj</code>， 该句被视为在子级作用域定义一个同名变量，并隐藏了上级变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"read y: %d"</span> % y) <span class="comment"># 读取全局变量</span></span><br><span class="line">  x = <span class="number">1</span>   <span class="comment"># 创建一个局部变量 x</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">run()</span><br><span class="line">print(<span class="string">"global x: %d"</span> % x)</span><br></pre></td></tr></table></figure>
<h4 id="global-与-nonlocal-语句">global 与 nonlocal 语句</h4>
<p>如果想在子级作用域中让上级作用域变量指向其他对象，可以用 <code>global</code> 与 <code>nonlocal</code> 语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># nonlocal x 这样声明会报错，python 不能找到非全局的上级变量 x</span></span><br><span class="line">    x, y = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = <span class="number">2</span></span><br><span class="line">        <span class="keyword">global</span> y</span><br><span class="line">        y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    print(<span class="string">"outer:"</span>, x, y)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"global:"</span>, x, y)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># outer: 2 1</span></span><br><span class="line"><span class="comment"># global: 0 2</span></span><br></pre></td></tr></table></figure>
<p><code>global</code> 最先出现，用于在局部引用全局变量，随后又加入 <code>nonlocal</code>，使子级作用域引用 <strong>非全局的</strong> 上级变量。</p>
<h4 id="类变量与实例变量">类变量与实例变量</h4>
<p>类变量的定义与访问其中两种方式：</p>
<ul>
<li><code>class_name.class_var</code></li>
<li>类定义内方法定义外 <code>class_var</code></li>
</ul>
<p>实例变量定义与访问有两种方式：</p>
<ul>
<li><code>obj_name.obj_var</code></li>
<li>在有 <code>self</code> 参数的方法定义中 <code>self.obj_var</code></li>
</ul>
<p>用访问实例的方式可以访问类变量，就像 <strong>在子级作用域访问上级变量</strong>，只能访问而不能让其指向另一个对象，而且如果实例变量与类变量同名则访问实例变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span>:</span></span><br><span class="line">    v1 = <span class="number">0</span>  <span class="comment"># 定义类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.v1 = <span class="number">1</span>   <span class="comment"># 定义实例变量，隐藏同名类变量</span></span><br><span class="line"></span><br><span class="line">cls.v2 = <span class="number">0</span>  <span class="comment"># 定义类变量</span></span><br><span class="line">obj = cls()</span><br><span class="line"><span class="keyword">print</span> cls.v1, cls.v2  <span class="comment"># 访问类变量</span></span><br><span class="line"><span class="keyword">print</span> obj.v1, obj.v2  <span class="comment"># 分别访问实例变量 v1 与类变量 v2</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串">字符串</h3>
<h4 id="模板">模板</h4>
<p>类似 C 语言的格式化字符串，用 % 号连接模板字符串（Template）与匹配元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'%s is a string. %d is a int.'</span> % (<span class="string">"Hello World"</span>, <span class="number">0</span>) <span class="comment"># 该表达式返回一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可将元组替换成字典，模板对应加入 (key)</span></span><br><span class="line"><span class="string">"I'm %(name)s, and I love %(num)g."</span> % &#123;<span class="string">"num"</span>:math.pi, <span class="string">"name"</span>:<span class="string">"Mike"</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原生字符串常量">原生字符串（常量）</h4>
<p>在字符串字面量前加 r ，会使之成为原生字符串字面量，不会对字符进行转义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r"\n"</span> == <span class="string">"\\n"</span> <span class="comment"># 返回 True</span></span><br></pre></td></tr></table></figure>
<h4 id="加操作">加操作</h4>
<p><strong>字符串只允许与字符串进行加操作</strong></p>
<h3 id="函数参数">函数参数</h3>
<h4 id="参数传递">参数传递</h4>
<p>函数形参（函数定义参数）复制了实参（传入函数的变量）的引用，类似 Java，对形参引用对象的修改实际上在修改实参引用对象，但让形参指向其他对象不会对实参有影响。</p>
<h4 id="缺省与变长">缺省与变长</h4>
<p>函数参数的定义顺序与调用顺序应该遵循：关键字参数–&gt;缺省参数–&gt;变长参数–&gt;关键字参变长数</p>
<h5 id="关键字参数">关键字参数</h5>
<p>最基本的一类参数，调用时可指明形参名（关键字）。与其他参数不同，必需赋值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> a, b</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 一般调用方法</span></span><br><span class="line">fun(b=<span class="number">1</span>, a=<span class="number">2</span>)  <span class="comment"># 指明形参名可乱序</span></span><br><span class="line">fun(<span class="number">1</span>, b=<span class="number">2</span>) <span class="comment"># 可行</span></span><br><span class="line">fun(<span class="number">1</span>, a=<span class="number">2</span>) <span class="comment"># 这样调用出错</span></span><br><span class="line">fun(a=<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 同样出错</span></span><br></pre></td></tr></table></figure></p>
<h5 id="缺省参数">缺省参数</h5>
<p>缺省参数有缺省值。除了顺序在关键字参数后以及有缺省值外，与关键字参数基本相同。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b=<span class="number">2</span>)</span>:</span>  <span class="comment"># b 为缺省参数</span></span><br><span class="line">    <span class="keyword">print</span> a, b</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="变长参数">变长参数</h5>
<p>参数个数不定，形参最终得到元组，调用时可不传，一个个传递或传一个元组。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, *b)</span>:</span> <span class="comment"># b 为变长参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">        <span class="keyword">print</span> a + i</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fun(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 用元组传递变长参数，加星号，称作解包</span></span><br><span class="line">fun(<span class="number">1</span>)  <span class="comment"># 不传或解包空元组都可行</span></span><br></pre></td></tr></table></figure></p>
<h5 id="关键字变长参数">关键字变长参数</h5>
<p>参数个数不定，而且必须指明关键字。形参最终得到字典，与变长参数类似，调用时可不传，一个个传递或传一个字典。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():    </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"get "</span> + k + <span class="string">"="</span> + str(v)</span><br><span class="line">fun(a=<span class="number">1</span>, s=<span class="string">"hi"</span>)</span><br><span class="line">fun(**&#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"s"</span>: <span class="string">"hi"</span>&#125;)  <span class="comment"># 字典解包，注意关键字必须为字符串</span></span><br></pre></td></tr></table></figure></p>
<h5 id="参数顺序">参数顺序</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b=<span class="number">1</span>, *c, **d)</span>:</span> <span class="comment"># 函数定义时形参须根据类型按序定义</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d1=<span class="number">4</span>) <span class="comment"># 函数调用时也根据类型按序传入</span></span><br></pre></td></tr></table></figure>
<h3 id="常识">常识</h3>
<h4 id="元组">元组</h4>
<ul>
<li>元素不能改变</li>
</ul>
<h4 id="false">False</h4>
<p>判断语句中None,False,空字符串“”,0,空列表[],空字典{},空元组()都相当于False</p>
<h4 id="虚拟环境">虚拟环境</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install virtualenv</span><br><span class="line"><span class="comment"># 创建虚拟环境，python3，无已安装包</span></span><br><span class="line">virtualenv -p python3 --no-site-packages venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate <span class="comment"># 激活</span></span><br><span class="line">pip freeze &gt; requirement <span class="comment"># pip freeze</span></span><br><span class="line">deactivate <span class="comment"># 退出虚拟环境</span></span><br></pre></td></tr></table></figure>
<h3 id="文件操作">文件操作</h3>
<h4 id="当前目录">当前目录</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<h4 id="简单文件读写">简单文件读写</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">col = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_path.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> df:</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> df:</span><br><span class="line">      tmp = line.strip().split(<span class="string">','</span>)</span><br><span class="line">      col.append(int(tmp[<span class="number">3</span>])) <span class="comment"># 读取第4列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'out_path'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> df: <span class="comment"># 'a' 追加</span></span><br><span class="line">  <span class="keyword">for</span> val <span class="keyword">in</span> col:</span><br><span class="line">    df.write(<span class="string">"%d\n"</span> % val)</span><br></pre></td></tr></table></figure>
<h4 id="在控制台运行源文件">在控制台运行源文件</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execfile(<span class="string">'python_code.py'</span>)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/C-Cpp-cheatSheet/" itemprop="url">
                  C/Cpp 杂记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-03T10:47:21+08:00" content="2016-06-03">
              2016-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="文件操作">文件操作</h3>
<h4 id="简单文件读写">简单文件读写</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ifstream in;</span><br><span class="line">in.open(<span class="string">"file_path"</span>);</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span>(in &gt;&gt; k)  <span class="comment">// 读取 int 型数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">ofstream out;</span><br><span class="line">out.open(<span class="string">"out_path"</span>, ios::app); <span class="comment">// app模式追加，默认覆写</span></span><br><span class="line">out &lt;&lt; ‘hello world’ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<h3 id="编程规范">编程规范</h3>
<h4 id="循环计数器与-运算符">循环计数器与 ++ 运算符</h4>
<p>考虑 while 和 do 计数循环： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(++i &lt; <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"while: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// i 不会被打印</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"do: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// i 被打印2次</span></span><br><span class="line">&#125;<span class="keyword">while</span>(i++ &lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里计数器 i 不能正常工作（打印一次），应该将计数器更新放在循环体避免失误，使用标准的 for 循环最好。</p>
<h4 id="结构体声明">结构体声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// 结构标记声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span> <span class="title">var_name</span>;</span> <span class="comment">// 结构变量声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125; var_name; <span class="comment">// 结构标记与变量同时声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125; struct_type, *p_struct_type;  <span class="comment">// 结构typedef名声明</span></span><br><span class="line">struct_type var_name; <span class="comment">// 结构变量声明</span></span><br><span class="line">p_struct_type var_name; <span class="comment">// 结构指针变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">struct_label</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125; struct_type, *p_struct_type;  <span class="comment">// 结构标记与typedef名同时声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *PNode; <span class="comment">// 链表结点结构体典型声明</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/31/ML-MLT-1-dualSVM/" itemprop="url">
                  机器学习技法第二课——Dual Support Vector Machine
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-31T10:49:11+08:00" content="2016-05-31">
              2016-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ML/" itemprop="url" rel="index">
                    <span itemprop="name">ML</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文是学习林轩田老师的机器学习技法第二课——Dual Support Vector Machine——的课堂笔记，有关 SVM 公式推导。</p>
<p>给定原公式： <span class="math display">\[
\frac{1}{2}\min_{b, \mathbf{w}} \mathbf{w^T w} \\\\
s.t. \ y_n(\mathbf{w^T \mathbf{x_n}} + b) \ge 1
\]</span> （为简化求解，公式与前次笔记稍有不同，但等价）这节课做了一系列的变换，最终有什么效果呢？</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/" target="_blank" rel="noopener">机器学习技法</a></li>
<li><a href="/2016/05/25/ML-MLT-0-deductionSVM/" title="linear SVM">linear SVM</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0" target="_blank" rel="noopener">拉格朗日乘数</a></li>
<li><a href="http://www.cnblogs.com/90zeng/p/Lagrange_duality.html" target="_blank" rel="noopener">简易解说拉格朗日对偶（Lagrange duality）</a></li>
<li><a href="http://xiaoyc.com/duality-theory-for-optimization/" target="_blank" rel="noopener">优化问题中的对偶性理论</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~htlin/mooc/doc/202_handout.pdf" target="_blank" rel="noopener">课件</a></li>
</ul>
<h3 id="拉格朗日乘数法">拉格朗日乘数法</h3>
<p>拉格朗日乘数法可以把限制条件和目标函数结合成一个整体。原公式整合成： <span class="math display">\[
L(b, \mathbf{w}, \alpha) = \frac{1}{2} \mathbf{w^T w} + \sum_{n=1}^{N}\alpha_n(1 - y_n(\mathbf{w^T \mathbf{x_n}} + b))
\]</span> SVM 求解公式变为： <span class="math display">\[
\min_{b,\mathbf{w}} (\max_{all\ \alpha_n \ge 0}L(b, \mathbf{w}, \alpha)) = \min_{b, \mathbf{w}}(\infty\ if\ violate;\ \mathbf{w^T w}\ if\ feasible)
\]</span></p>
<h3 id="拉格朗日对偶问题">拉格朗日对偶问题</h3>
<p>利用对偶问题，对上步的求解公式取下限： <span class="math display">\[
\min_{b,\mathbf{w}} (\max_{all\ \alpha_n \ge 0}L(b, \mathbf{w}, \alpha)) \ge \max_{all\ \alpha’_n \ge 0} (\min_{b,\mathbf{w}} L(b, \mathbf{w}, \alpha&#39;))
\]</span> 至于为何成立我没有细究，只能说这符合直觉。因为，考虑 <span class="math inline">\(L(b, \mathbf{w}, \alpha)\)</span> 为一个波动的函数，视 <span class="math inline">\(\max\)</span> 为取波峰， <span class="math inline">\(\min\)</span> 取波谷，那么从波峰中最小的应该不小于波谷中最大的。</p>
<p>有证明表示，对拉格朗日对偶问题，如果满足 <strong><em>强对偶</em></strong> 的三个条件，原始函数为凸函数、原始问题可解、原始限制条件是线性的，就可以在上式中取等，而 SVM 刚好满足。 : P</p>
<h3 id="关于-alpha-函数">关于 <span class="math inline">\(\alpha\)</span> 函数</h3>
<p>接下来对求解公式做2步“简化”，使之成为仅关于 <span class="math inline">\(\alpha\)</span> 的函数。</p>
<p><strong><em>去 <span class="math inline">\(b\)</span>：</em></strong> 考虑在极值点，变量的梯度都应该为 <span class="math inline">\(0\)</span>，所以 <span class="math inline">\(b\)</span> 的梯度 <span class="math display">\[-\sum_{n=1}^N \alpha_n y_n = 0\]</span> 把该式置于条件中并化简，得到求解公式等价式： <span class="math display">\[
\max_{\alpha_n} \min_\mathbf{w}(\frac{1}{2} \mathbf{w^T w} + \sum_{n=1}^{N}\alpha_n(1 - y_n \mathbf{w^T \mathbf{x_n}})) \\\\
s.t.\ all\ \alpha_n \ge 0,\ \sum_{n=1}^N \alpha_n y_n = 0
\]</span></p>
<p><strong><em>去 <span class="math inline">\(\mathbf{w}\)</span>：</em></strong>　<span class="math inline">\(\mathbf{w}\)</span> 的梯度 <span class="math display">\[\mathbf{w}_i - \sum_{n=1}^N \alpha_n y_n x_{n,i} = 0 \\\\
\Rightarrow \mathbf{w} = \sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n}\]</span> 把该式置于条件中并经过化简，得到最终的求解公式： <span class="math display">\[
\max_{\alpha_n} (-\frac{1}{2}|\sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n}|^2 + \sum_{n=1}^{N}\alpha_n) \\\\
s.t.\ all\ \alpha_n \ge 0,\ \sum_{n=1}^N \alpha_n y_n = 0,\ \mathbf{w} = \sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n}
\]</span> 注意其中的 <span class="math inline">\(\mathbf{x_n}\)</span> 及其求和均为向量，原本的求最小因为消去 <span class="math inline">\(b, \mathbf{w}\)</span> 而除去。</p>
<h3 id="kkt-条件">KKT 条件</h3>
<p>对凸优化问题，KKT 条件是一组解成为最优解的充分必要条件。（见<a href="http://xiaoyc.com/duality-theory-for-optimization/" target="_blank" rel="noopener">“优化问题中的对偶性理论”</a>）而 SVM 求解原式和对偶式（强对偶）都有最优解，所以最优解满足 KKT 条件。 这其中有 2 个条件可以用于从最最优 <span class="math inline">\(\alpha\)</span> 中解出最做优 <span class="math inline">\(b, \mathbf{w}\)</span> <span class="math display">\[
\mathbf{w} = \sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n} \\\\
\alpha_n(1 - y_n(\mathbf{w^T \mathbf{x_n}} + b)) = 0
\]</span></p>
<h3 id="二次规划求解">二次规划求解</h3>
<p>与上一课一样，因为求解问题是一个二次规划问题，所以可以借助相关的工具。在此之前，需要做一些变换。</p>
<p><strong><em>最大化变最小化</em></strong>　　最优化工具往往求最小值。求解公式取相反数： <span class="math display">\[
\min_{\alpha_n} (\frac{1}{2}|\sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n}|^2 - \sum_{n=1}^{N}\alpha_n) \\\\
\]</span></p>
<p><strong><em>隐藏 <span class="math inline">\(\mathbf{w}\)</span> 的限制条件</em></strong>　　使公式完全变为关于 <span class="math inline">\(\alpha\)</span> 的函数，剩下的 <span class="math inline">\(x, y\)</span> 都是已知量 <span class="math display">\[
s.t.\ all\ \alpha_n \ge 0,\ \sum_{n=1}^N \alpha_n y_n = 0
\]</span></p>
<p><strong><em>展露二次项系数</em></strong>　　求解公式中二次项系数不易发现，做拆分： <span class="math display">\[|\sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n}|^2 \\\\
=(\sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n})^\mathbf{T}(\sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n})
=(\sum_{m=1}^{N} \alpha_m y_m \mathbf{x_m^T})(\sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n})\\\\
=\sum_{m=1}^{N} \sum_{n=1}^{N} y_m \mathbf{x_m^T}  y_n \mathbf{x_n} \alpha_m \alpha_n
\]</span> 注意该式原始是2个（由多个向量求和得到的）向量的内积，最后一步变换使用了向量的分配律。可见，二次项 <span class="math inline">\(\alpha_m \alpha_n\)</span> 的系数为 <span class="math inline">\(y_m \mathbf{x_m^T} y_n \mathbf{x_n}\)</span>。</p>
<p>最后给出 <strong><em>完整公式</em></strong>： <span class="math display">\[
\min_{\alpha_n} (\frac{1}{2}\sum_{m=1}^{N} \sum_{n=1}^{N} y_m \mathbf{x_m^T}  y_n \mathbf{x_n} \alpha_m \alpha_n - \sum_{n=1}^{N}\alpha_n) \\\\
s.t.\ all\ \alpha_n \ge 0,\ \sum_{n=1}^N \alpha_n y_n = 0
\]</span> 利用二次规划工具解决该问题，解出 <span class="math inline">\(\alpha\)</span> 后，再利用 KKT 公式的2个条件，解出 <span class="math inline">\(\mathbf{w}, b\)</span>: <span class="math display">\[
\mathbf{w} = \sum_{n=1}^{N} \alpha_n y_n \mathbf{x_n} \\\\
b = y_n - \mathbf{w^T \mathbf{x_n}}\ ,\  s.t.\ \alpha_n \ne 0
\]</span></p>
<p>值得注意的是，二次项系数矩阵是 <span class="math inline">\(N \times N\)</span> 的大型矩阵，而且并非上节课的对角矩阵，需要专为 SVM 设计的二次规划求解工具。</p>
<h3 id="sv-与后续">SV 与后续</h3>
<p>很明显，利用 <span class="math inline">\(\alpha\)</span> 求解 <span class="math inline">\(\mathbf{w}, b\)</span> 时，如果 <span class="math inline">\(\alpha_i\)</span> 为0，对求解没有影响。也就是说，对应 <span class="math inline">\(\alpha_i = 0\)</span> 的向量（数据点）对求解没有影响。联系上节课，即对应 <span class="math inline">\(\alpha_i \gt 0\)</span> 的向量为支持向量（SV）。</p>
<p>课程中对原始向量 <span class="math inline">\(\mathbf{x}\)</span> 做了向N维向量 <span class="math inline">\(\mathbf{z}\)</span> 的映射，<span class="math inline">\(\mathbf{x}\)</span> 替换成 <span class="math inline">\(\mathbf{z}\)</span> 后对推导没有影响。而这节课的变换似乎没有简化求解，至于为何目的，只有后续揭晓了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Blunt" />
          <p class="site-author-name" itemprop="name">Blunt</p>
          <p class="site-description motion-element" itemprop="description">email：summer15y@163.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">61</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Blunt</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

  

  


</body>
</html>
